----
-----前言-----
# 文档结构
-----章节分隔-----
# 一级标题
  > 二级标题
    × 三级标题、
      ××四级标题
        s1：第一步
        s2：第二步
        a: 方法1、情况1
        b：方法2、情况2
        ！注意
        ？疑问
# 使用帮助
    a /program/linuxusage_programming 文档 "如系统调用的查看
    b man命令
    c man在线文档搜索标签网页

# unix环境高级编程apue中实例使用:
  > 本书实例源码：
    × 代码下载位置：
      cd ~/promgram/apue.3e/
      ./include "实例所需自编头文件apue.h，c标准函数原型/系统调用原型/自定义
      ./lib     "实例所有的libapue.a库及其源文件，包含了本书自编函数定义。
      ./其他    "本书每章节实例源文件

    × "apue.h" --对应libapue.a
      c标准头文件，如<stdio.h>,<stdlib.h>
      系统调用头文件和包裹函数原型：<unistd.h>等
      本书自定义常量的宏定义，如MAXLINE
      自编函数的原型，如err_exit(),errpsys()等错误处理函数。
      数据类型定义，
    × 库/头文件配置：
      从apue书中网址www.apuebook.com下载并解压得到apue.3e
      这个文件夹包含本书实例源码及其库头文件依赖，见上。
      apt install libbsd-dev "安装libapue库依赖,否则编译libapue时threads报错
      cd ./apue.3e
      make "根据Makefile进行编译，即生成libapue.a
      cp ./lib/libapue.a /usr/local/lib/
      cp ./include/apue.h /usr/local/include/
      
    × 编译使用实例：
      cd ./book实例/apue实例/1-4mycat/ "apue书中实例代码在./apue.3e/figlink
      gcc mycat.c -lapue -static -o test
      
      

-----系统调用-------
man 2 syscalls:查看linux系统调用函数等

----错误处理-------
> 错误与异常：
  以现有的apue的讲解，
  × 错误:函数调用的错误
    a.如果是系统调用出错，往往会返回值<0且errorno保存错误码
    b.库函数错误,返回值见函数描述
    c.自定义函数出错，返回值取决于开发者怎么实现
    总之，我们应该根据错误的类型进行针对处理，而不是一味地终止，
    更不能无视忽略
  × 异常:各种产生信号的情况就是异常，后续补充c++语言层面的异常处理
    在这里，我们简单的认为异常就会产生信号，因此异常的处理取决于对
    信号的信号处理方式。我们不能简单得认为把异常(信号)交给内核作默认
    信号处理就可以了。比如SIGWCH SIGCHILD等
  需要注意的是，有些系统调用出错的同时也会产生信号，
  比如write写至无读端-errorno=EPIPE 也产生SIGPIPE信号

> unix系统函数调用出错会出现以下：
    × 函数返回非正数：
    × 全局变量errno自动置位正整数错误类型:
        .多线程下，线程有各自的errno局部变量。
    × 尽可能根据errno进行错误处理:
        .终止+自定义输出errno错误描述：
        .恢复运行:
            如errno=EAGAIN,应尝试继续写/读

> 错误类型：
  系统调用失败,往往返回值<0且errno存放错误码
  errno错误码分为可恢复和致命性错误。
  开发人员可根据errno错误码，编写相关的错误处理代码。
  × 致命错误:
    开发人员必须让进程终止，如调用err_sys()--strerr(errno)+exit(0)
  × 可恢复性错误：
    开发人员处理后续的恢复动作。如非阻塞read或write返回-1,errno=EAGAIN。
    此时应继续循环调用非阻塞read或write
> 错误码：
  对于进程:一个全局变量errno，系统调用失败，则会自动置位该变量。<errno.h>
  对于线程:一个线程内部的errno，pthread_**线程函数调用失败，会保存错误
  码
  6 EXIO：
        无此设备或地址。--
        eg：
        × O_NONBLCk模式下open一个FIFO，在没其他进程为读而打开这个FIFO，只写open会立即返回-1,
          errno=EXIO
    11 EAGAIN：
        再尝试以下--可恢复
        eg:
        × 非阻塞read(内核读缓冲区无数据)或write(内核写缓冲区已满)导致失败，立即返回-1.
          errno只EAGAIN
    32 EPIPE：
        写无读的管道 --
        eg:
        × pipe，fifo的write时，尚无进程为读而打开相应pipefifo导致失败，返回-1,errno至EPIPE
    × EINT：
      ×× sigsuspend系统调用总是返回-1且errerno---表示被中断的系统调用


> 错误函数：
    errno全局变量:
        定义在<errno.h>中，可被赋予的常量有，
        系统函数调用出错，便会是errno置相应正值
    char* strerror(int errno):
        <string.h>中定义，返回errno 对应的错误描述字符串
    void perror(char* message):
        <stdio.h>中定义，标准输出message: errno对应的错误描述信息
错误包裹函数：apue自编了错误包裹函数，声明在apue.h,定义在error.c中。
    err_quit():
        基于exit(1)+格式化字符串标准输出。
        针对非系统调用或非标准函数调用出错。
    err_sys():
        基于strerror(int errno)+exit(1)+格式化字符串标准输出。
        针对系统调用或标准函数调用出错，会基于errno变量，输出对应的错误信息字符串。
        如permission denied.

--------文件io、标准io、终端io--
# 缓冲区：
  > 结构：
     
             fgets            fputs
               ∧                ︱
    -----------︱---------------︱----------------
               ︱               ∨              |× 标准全缓存：常规文件
    用户    |标准io读缓冲|   |标准io写缓冲|    |  缓冲区满了才进行实际io
               ︱               ︱             |× 标准行缓冲：标准输入输出
               read            write           |  缓冲区遇到换行符。
               ∧                ︱             |× 标准无缓存：标准错误
    -----------︱---------------︱-----------------
               ︱               ∨              |× 独立进程open打开文件就为该
       |打开文件读缓冲区| |打开文件写缓冲区|   |  fd创建内核读/写缓冲区和
               ∧                ︱             |  打开文件表项
     内核      ︱               ︱             |
               ︱预先读         ︱ 延迟写      |
    -----------︱---------------︱-----------------
               ︱               ∨              |
                       
    磁盘
     
  1. 同一进程内read(fd=0)-->buf数组-->write(fd=1).p7 图1-4
     实现标准输入复制到标准输出
     ./test <file1.txt >file2.txt "使用重定向将文件file1.txt复制到file2.txt
  2.同一进程内fgetc(fp=STDIN)-->int c -->fput(fp=STDOUT).p8 图1-5
      实现标准输入流复制到标准输出流
      同上利用文件重定向可实现文件复制
  3.
# 文件io:
  > read():
   × 默认是阻塞的读取(0,指定字节数]--因此需要手动while(>0)循环读至返回值<=0
     返回值=0,读至文件尾。
     返回值<0,读失败。
    返回值=-1,出错
             非阻塞模式下，若内核读缓冲区无数据，则立即返回-1,errno设为EAGAIN。

    > write():默认是阻塞的写入指定字节数--因此无需循环write。
              返回值=-1.write错误。
              返回值=指定字节数.写入成功---返回0,只与指定字节数为0相关。
              非阻塞模式下，
              返回值(0,nbtye],即一次写入小于指定字节数--此时需要循环write
              若内核写缓冲区已满，则立即返回-1,errno设为EAGAIN
  > close():
    关闭一个打开文件(文件描述符)，使得该fd引用计数减1
    × 针对父子进程和多线程的close使得fd引用计数减为0,则文件关闭.
      后面提到文件打开实际是创建文件打开表项+内核读写缓冲，
      文件关闭是指清理和释放内核发送(写入磁盘)和接收(丢弃)缓冲区、文件表项。
    × 针对多线程环境，文件io操作是系统调用，因此是原子操作，是线程安全的
          但注意类似空悬指针的空悬fd问题(线程使用另一个线程关闭的fd)
        × 针对socket套接字，close()会
          丢弃套接字接收缓冲区数据
          等待发送完发送缓冲区数据之后并附加发送一个FIN报文(发起端口连接)
          之后socket套接字关闭，内核负责四次挥手以完成断开连接。
        
# 标准io:
  当我们读或写一个文件，假设使用文件io read/write，那即便每次就写少量字节，
  我们都得调用一次write系统调用，读一次少量字节也得调用一次read系统调用。
  这样频繁地进行系统调用，进出内核，很费cpu时间(用户cpu时间+系统cpu时间)。
  而apue-3.9 io效率小节中不同buf 大小对read文件效率比较一图中指出，
  buf大小为4096byte最适的-再大不但浪费内存空间也对提高读速率有限。
  如果，不考虑(socketd等)读写数据的实时性，完全可以为fd设置一个用户缓冲区：
  读时，将需读数据大小累积到达读用户缓冲区大小，此时才调用一次read系统调用
  写时，将写数据放至写用户缓冲区直至满了，此时才调用一次write。
  标准io就是这个原理，其操作对象是带缓冲的文件流，通过这个标准缓冲，减少
  read和write系统调用的次数，这对实时性要求不高的文件如普通文件，终端设备
  的读写效率有很大提高。
  > fgetc():
    从标准io流读取一个字符
    返回值:int
    不为EOF：成功
    EOF    :文件尾部或出错
  > fputc():
    将int ch写入标准io流
    返回值：int
    ch ：成功
    EOF：失败
    eg:结合fgetc和fputc将标准输入流复制到标准输出流，讲解标准缓存
    "如果使用fgetc实现按键检测，如果我们按下上-下-左-右键-ENTER
    "因为上-操作够快，所以主观感受就是按下 下键立马就执行了下-操作。
    "如果我的上-操作执行了5秒，那根据fgetc的特点，那我下个操作对应的按键
    "是5秒前，我随上按键键入的下按键，这是不合理，我下个操作，应该是
    "操作执行前刚刚按下的某个按键,此外，ENTER也不合理，我希望我按下一个键
    "不用等待输入ENTER,就能立马被fgetc读取到
    ./c语言和book实例/c标准io/test -T 1
    123 "键入123按下enter键-按下enter后才调用read 1次,fgetc(stdin)调用了四次
    123 "输出123换行fput(ch,stdout)调用了4次,第4次输出enter才实际行缓冲换行

  > fgets():
    在读取到首个换行符为止(或结束符之前为止)但<=n-1字节数，
    尾部添加一个结束字符，存放至我们指定的buf(如4096)中
    返回值:    
      非NULL:成功，返回buf指针。
      NULL:文件尾或出错
    fgets使用需注意：
      a.应选择合适的行buf大小。即使设为4096字节，也可能由于行过长
        一次fgets读取不到一个完整行。

    
  > fputs():
    首个结束字符之前的字符串写入指定流
    返回值：
      >=0:成功写入字节数.
     EOF(-1):出错。
    因此，需注意：
      a.输出结果可能是一个不完整或一个或是多个行（字符串中间存在换行符号）
        想输出一行，需确定字符串的第一个结束字符前一个字符是换行符
              
    > fread():读取nobj个size，返回值=nobj，读取正确;返回值<nobj,读到文件尾部
              或错误。
    > fwrite()：
        × 尝试写入nobj个size字节从char* buf 至FILE* 流。
        × 由于一次可能写不完，应循环fwrite()。
        × 应ferror判断<0,进行错误处理。
        × 返回值:
            >=0：成功写入ret字节
            <0 : 错误,通过ferror()或feof()系统调用进一步判断
        
    >snprintf():---比prinf更安全的格式化输出
        输出<=(n-1)且首个'\0'之前为止，并给尾部添加'\0'，至buf。
        返回值:
            >=0: 存入buf的字节数(尾部添加的'\0不包括.
            <0 : 编码错误
    > feof():
      判断标准流FILE*的文件尾标志来标准io读操作的失败
      是读到文件尾还是真的出错
      返回值：
        非0 :文件尾
        0   ：出错
    > fflush():
      对流(文件指针)的标准io缓冲区进行强制冲洗:
      × 标准io写缓冲区:将所有未写数据(输出数据)传送给内核，但这并意味
        这会真正写入磁盘文件,这类似文件io write写。
         (可调用fsyc()实时写入磁盘)
      × 标准io读缓冲区:所有未读数据丢弃
      返回值：
        0  :成功
        EOF:出错
    > fclose():
      × 关闭一个打开的流(文件指针)+标准io缓冲区释放.
        该文件被关闭之前会自动调用fflush冲洗缓冲区
      × 只要进程是正常终止(调用exit退出或main中返回)，都会对文件指针FILE×
        隐式的进行fclose。
      返回值：
        0  ：成功
        EOF：出错

    fprintf()等需考虑标准io缓存区，即进程缓
        冲区的刷新，即全缓冲区、行缓存区、无缓冲区等刷新的区别。其中标
        准输入、输出、错误默认重定向至终端，而终端流则是行缓存区。

    因此，实际编程中：
    对于文件io，只需考虑是否需要while(read)、如何结束该while和err_××()处理
    文件io调用错误。。
    对于标准io，除上述三点之外，还需考虑标准io缓存区刷新才会实际io操作相关
    问题。

# 网络io:
# 多进程的文件共享：
  > 文件操作的三大元素：内存级
    进程                 系统                   文件系统
   文件fd表---------->打开文件表------------>v/i node
   同一进程：
      fd=1------------|同一打开|---|同一v |
       ||            /|文件表项|   |i node|
       ||dup复制fd  /
       ∨           / 
      fd=2--------/
   父子进程：
     |父fd=1|----------|同一打开|---|同一v |
        ||            /|文件表项|   |i node|
        ||fork继承fd /
        ∨           /
     |子fd=1|------/

   独立进程：
     |进程1 fd=1|---|独立打开文件表项|-----|同一v |
                                          /|i node|
     |进程2 fd=7|---|独立打开文件表项|---/
   × 系统进程表,每个进程表项包含：
       该进程的文件描述符表
   × 进程文件描述符表:索引代表fd,每个文件fd表项包含
       文件描述符标志(close-on-exec)，默认是0不关闭，可通过fcntl设置
       指向文件表项的指针
   × 系统打开文件表，每个打开文件表项包含：
       1. 当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）
       2. 打开文件时所使用的状态标识（即，open()的flags参数）
       3. 文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式）
       4. 与信号驱动相关的设置
       5. 对该文件i-node对象的引用
       6. 文件类型（例如：常规文件、套接字或FIFO）和访问权限
       7. 一个指针，指向该文件所持有的锁列表
       8. 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳
   × v node和 i node：
     v node ：文件类型、对该文件进行各种操作函数(文件锁？)的指针、inode指针
     i node :文件所有者、文件长度、指向文件数据块在磁盘位置的指针
  
  > 多进程文件共享安全：
    tlpi一书中指出linux所有系统调用都是原子操作，也就是说譬如write、read
    等系统调用是不用加锁的。
    多线程，多进程：
     安全不等同于同步
    × 进行读(read默认是从头读)，基于文件表项中偏移量进行的。
      read--因为各线程/父子进程共享打开文件表项--同一文件多读是安全的。
           |__因多个独立进程有各自独立的打开文件表项--同一文件多读是不安全
    × 进行写(默认可由open的文件描述符状态标志flags指定是覆盖写/清0写/追加写)
      如果是O_APPEND追加写,则每次都会根据文件inode的文件长度和打开文件表项
      的偏移量相互更新。
      "标准io流通过fopen打开时也可指定type追加写，所以这也适用标准io写 
      write-如果open以O_APPEND--各线程和进程共享inode-同一文件多追写安全
   
---------
> 程序启动
  s0:c程序编译时，编译链接器会使得实际的可执行文件被启动例程代码包裹，
      实际的main函数的调用和返回实际是被启动例例程代码包裹的。
  s1:当启动程序时，实际是调用exec函数以启动例程的其实地址
     作为程序的入口开始执行。
  s2:启动例程执行时，进入内核获取命令行参数和环境变量返回给
     int main(int argc,char* argv[]),为调用main()做好准备
  s2:启动例程调用main函数
  s4：main函数如果显式或隐式调用return语句则返回到启动例程
  s5:启动例程调用exit()进行进程退出
      
        ^
     
        ν

> 进程终止：
  进程的终止可以分为正常终止和异常终止。
  对于正常终止分为两步：进程退出(用户)--->进程终止(内核)
  对于异常终止就分为：信号递达-->进程终止(或暂停)
  -----------------------
  用户：
  正常终止：                            异常终止：终止或暂停
  用户空间在指定发起的终止          由内核对递达给进程的信号进行信号处理
    |main显隐式|----------|             |调用abort|--------|(SIGABORT)
    |调用return|          |                                |
                          |             |进程硬件异常|-----|(如SIGFPU
  |-----|调用   |         |             |或软件条件  |     |SIGPIP)
  |     |exit() |         |                                |
  |                       |             |最后一个线程  |---|(SIGCONCEL)
  |  |--|调用             |             |对取消请求响应|   |
  |  |  |_exit()|         |                                |______________
  |  |                    |                                 if(默认终止)  |
  |  |--|调用   |         |                                               |
  |  |  |_Exit()          |                                               |
  |  |                    |                                                
  |  |  |最后一个线程  |--|                                               |
  |  |  |显式隐式return|  |                                               |
  |  |                    |                                               |
  |  |  |最后一个线程调|--|                                               |
  |  |  |pthread_exit()|  |                                               |
  |  |                 |  |                                               |
  |  |                    ν                                               |
  |--|------------>|启动例程  |                                           |
     |             |调用eixt()|                                           |
     |                  |                                                 |
     |                  ν                                                 |
     |             |atexit处理函数|                                       |
     |                  |                                                 |
     |                  ν                                                 |
     |____          |fclose关闭|                                          |
          |         |标准io流  |                                          |
          |             |        _________________________________________|
  --------|-------------|-------|--------------------------------------
  内核:   |             |       |
          ν             ν       ν
    |调用do_exit进行进程内核资源清理，如下       |  
    |将task_struct的标志成员设置为PF_EXITING。   |    
    |调用del_timer_sync()删除任一内核定时器。    |
    |调用exit_mm()函数，释放进程占有的mm_struct。|
    |调用sem_exit()函数。释放进程的信号量。      |
    |调用exit_files()递减fd引用计数              |
    |exit_fs()递减文件系统数据的引用计数。       |
    |task_struct的exit_code成员中的任务退出码    |
    |置为exit()提供的退出码。 !                  |  
    |调用exit_notify()向父进程发信号SIGCILD, !   |
    |并把进程状态置为EXIT_ZOMBIE                 |   
    |do_exit()调用schedule()切换到新的进程。     |                      
    |处于EXIT_ZOMBIE状态的进程不会再被调度       |       
  -------------------------------------------------------------------
   × 终止码的确定：
     无论进程怎么终止，内核都会为其保存终止码(exit_code成员)
     但是正常终止和异常终止的终止码的确定方式不同，这点必须搞清楚
     因为很多时候父进程需要子进程终止的原因
     ×× 正常终止：
        终止码=退出码(退出状态exit status)
        显然，我们能够设置我们的退出码-退出原因规则，
        在进程要退出时指定退出码，以便我们确定进程退出的原因。
        如:一般进程成功执行--退出码0
        遇到系统调用或库函数调用或函数调用出错时(返回值<0)
        如果这种错误不可恢复，则我们要退出运行，则在退出时可以指定退出码
        如:shell脚本不能执行--退出码137
        退出码隐形规则：
          a.调用上面三个退出exit不指定退出状态参数;
            main调用无返回值的return;
            main未声明返回值为整型;
            返回不确定的退出码
          b.main声明返回值类型为整型且隐式调用return。
            返回退出码0
          c.当最后一个线程显示或隐式调return或pthread_exit()时
            会启动例程返回退出码0.
      ×× 异常终止：
         异常终止的终止码，不是用户能指定的，因为这时由内核确定的。        
   × 终止状态获取：
     无论怎样终止，内核总会为父进程保存子进程的
     终止信息：进程id、终止码、进程cpu使用时间总量
     剩余资源：内核栈、thread_info、task_struct
     有时父进程为了知道子进程的终止原因或者为了避免子进程僵尸进程
     可以调用wait/waitpid获取进程的终止码(同时也会清理终止进程的剩余资源)
     waipid(1023,&static,0) "阻塞等待1023进程终止。
     waipid返回后可通过定义在<sys/wait.h>中的宏函数可以对status判断：
     if(WIFEXITED(status))
        WEXITSTATUS(STATUS); //如果是正常终止，我们应该获取的时终止码
     else if(WIFSIGNALED(status))
        WTERMSIG(status); //如果是异常终止，获取终止信号
     else if(WIDSTOPPED(status))
        WTSTOPSIG(status);//如果是异常暂停，获取暂停信号
-----------------------------
    >正常终止：
        安装代码执行逻辑通过显式（代码内调用exit()函数）或隐式（代码内
        return或没有return或exit）地调用exit类函数结束进程（启动例程）
        正常终止肯定会调用带终止状态的exit、_exit、_Exit三个函数之一。

        × main() return返回。
            a.若main返回值为整型，则return 0等价与exit(0),
                return 1等价与exit(1)
            b.若main返回值为整型且无renturn或exit，则返回的终止状态0.
            c.其余情况返回的终止状态不确定。echo $?打印刚刚终止进程的状态
           
        × exit()：进行一些清理处理，再返回内核。常用！
          exit(0)正常退出，exit(1)表示函数调用或其他处理失败返回
          0表示正常结束，1-255表示出错
            s1：调用通过atexit()注册的终止处理程序（函数）apuev3 p160
            s2：释放全局对象、变量;调用close()关闭文件描述符，见apuev
                p53 unp p93;调用fclose()刷新标准io，释放标准io缓冲区（即关闭
                打开的流
        × _exit()或_Exit():立即进入内核。
        × 进程的最后一个线程执行return。该线程的返回值不作为进程进程返回
           值，当最后一个线程从启动例程返回时，该进程以终止状态0返回
        × 进程的最后一个线程调用pthred_exit().同上，进程总是返回终止状态0.
           与pthread_exit()的参数无关。

    >异常终止：
        ×：自身调用abort()。产生SIGABRT（异常终止，该进程终止+coredump）
        ×：接到一个自身进程（如调用abort()）或其他进程或内核（如进程引用
           地址空间之外的存储单元、进程进行除以0运算）产生的信号。
        ×：最后一个线程对取消请求进行响应。
    
    >终止状态：进程终止产生的一个整型终止状态值，不同的值具有不同的含义。
        × 终止状态产生:
            a 正常终止：由正常终止的进程本身产生返回一个指定或是不确定的值
            b 异常终止：由内核产生返回一个表示进程异常终止原因的终止状态
        × 终止状态获取：wait类函数的int statloc 参数获取终止状态。
            WIF××(statloc)开头宏函数分析终止状态获取退出状态、信号编号等
            pr_exit()打印WIF××宏函数的分析信息。

    >终止结果：无论值正常终止还是异常终止都有.
        ×：均由内核向父进程返回一个SIGCHILD信号（子进程状态改变，
           默认系统忽略该信号，父进程忽略该信号，不进行处理）
        ×：内核均会保存一份关于终止进程的终止信息（进程号;终止状态;
           cpu等资源统计信息）
        ×：无论以何种方式终止进程或exit函数终止进程，最终均会执行内核
           同一段代码位相应进程关闭所有打开的文件描述符和释放其使用的
           存储器（内存、硬盘等).
           对于标准io流，只有正常终止才会冲洗待未写数据的标准io流。
  > 终止、退出、中断、挂起
  > 终止状态、退出码、错误码、返回值

#进程状态：
    进程空间分为用户空间，内核空间
    用户空间:用户态,
    内核空间：内核态
       a.当发生终端输入/硬件异常/系统调用都会由用户态进入内核态
       b.需要注意的是，内核态并没有进程界限，cpu进入内核态会检查
         所有进程pcb中的信号递达。
> 就绪:R                                                        [进程状态]
  已加入cpu进程运行调度队列，等待被分配cpu时间片
> 运行：R                                                       [进程状态]
  占用cpu，执行代码
> 停止: top和ps称这种状态为:stoped
  程序暂停，保存至外存，主动恢复。
  eg:
  ctrl+Z->前台进程暂停->fg %1恢复至前台运行
  ps -ef查看该进程state为T(作业控制暂停)
> 挂起：                                                        [进程状态]
  调用pause()系统调用进程暂停,保存至外存，直到内核执行关于本进程的一个
  信号处理程序返回(显然指的是捕捉信号处理函数)
  ! 暂停，睡眠都是挂起状态，即进程暂停，内存映像保存至外存
  ! 但ps和top中 睡眠和挂起称为(interruptible) sleeping
    io操作阻塞称为(uninterruptible)sleeping
    暂停称为stopped
 
> 睡眠：
  也是挂起。
  sleep 系统调用wrapper(由缺陷)，暂停(可中断的睡眠S)直至
  过了指定的墙上时间返回或内核执行关于本进程的一个信号处理返回
  alarm系统调用,暂停直至
  过了指定的闹钟时间秒数。
> 阻塞：                                                        [进程状态]
  进程由于等待事件或资源而退出cpu调度,保存至内存。(不可中断的睡眠D)
> 终止：                                                        [进程状态]

# 进程的内存空间布局：
  进程占用4G的虚拟内存地址空间(相对地址0x0-0xffffffff)
  其中高位1G为进程内核空间，低3G为进程用户空间。
  >
  > 用户空间：
  　× mmp:
  　　内存映射段，存放动态库映射地址。动态库在内存中只有一份副本，系统所有进
      程只在他们的mmp存放虚拟地址，通过地址映射，使用内存中那个唯一备份。
      动态库内存布局，自己库的bbs、data、正文段存放在mmp，而堆栈、堆存放
      在进程内存中。
-----多进程----
# 多进程：
  > 竞争条件：
    对共享资源的同时的读写/写写，都会形成资源竞争，造成不可预料的结果
    进程-进程;线程-线程;线程-信号捕捉处理;信号捕捉处理嵌套
    尽可能不用共享资源;非得用就附加同步措施;
    > 父子进程内存关系:
        ×子进程是父进程的一份拷贝:
            理论上，子进程拷贝了父进程的data,bbs,heap,stack,(命令参数和环境变量)
            而不是与父进程共享一份进程内存。
            此外，父子进程共享text段，fork之后父子进程继续执行text段指令
        ×写时复制：
            实际实现的时候，只有父或子进程需要对上述的应拷贝的内存空间进行写时，
          才会拷贝该piece内存(虚拟内存地址页表的页号+偏移量)。否则不会拷贝。
        ×进程内存空间相互独立:
            总之，任意进程独占一份内存空间(当然共享text段)，因此进程之间相互独立
            那进程之间的通信就尤其困难.
# 父子进程继承和共享资源：
  > 虚拟内存-物理内存-虚拟内存地址-物理内存地址
    虚拟内存地址的范围为由地址总线的位数决定的，64位地址总线可寻址16T
    物理内存地址的范围由实际物理内存容量决定，如我的内存是8G=2^33
    虚拟内存空间--------物理内存空间--------硬盘(充当虚拟内存)
    eg:
     访问变量-->确定虚拟内存页号+偏移量-->内核中mmu进行内存映射确定物理页帧-
     ->去内存上定位物理内存页帧->若没在内存->去硬盘查找该页帧并加载到内存上
  > fork后：
    fork之后子进程是父进程的副本，即子进程拥有父进程命令行参数、环境变量
    堆、栈、内存映射段、bbs、data、代码正文段的副本,即整个父进程内存空间
    的副本
    ! 这里的副本只是进程虚拟内存空间，此时并不实际制作一个物理内存副本)。
    实际实现时：
    × 对于代码正文段
      是共享的且只读的.(内存映射段是所有进程共享的)
    × 对于其他段，则是写时复制--即子进程实际修改某一页时才会为该页
      制作一个副本(物理内存页帧)
    子进程会继承父进程的：
      文件描述符fd
      信号处理

  >fork至exec之间
    × 此时在子进程中我修改某一页，
      如：
        修改一个全局变量的值--若缺页，则子进程制作一个父进程该页帧的副本
    × 如果继承的信号处理方式是信号捕捉处理函数，exec则会将其设为默认。
        
  >exec后：
    ×这就是执行一个新的程序，内存空间重新布局。

  > fork后继承：
     子进程对父进程的继承：
    × fd:
      ×× 所有shell都会为执行的新程序打开0-1-2标准输入输出错误三个fd
         这三个fd都定向至控制终端，也会被子进程继承。
      ×× 继承文件描述符标志close_on_exec
    × 信号处理
      ×× 继承父进程的屏蔽信号集
      ×× 但对继承父进程的未决(未处理、挂起)信号集置为空集
    × 进程组id/会话组id/控制终端 
    × 工作目录:
    × 根目录:
    × 文件掩码：
    × 共享存储段(动态库、mmap)
    × 环境
    × 资源限制
    × 不继承父进程的文件锁
    × 清理父进程未处理的闹钟
  > exec后继承
    虽然fork后子进程内存空间是父进程的副本，但exec会加载的新程序
    会重新进程内存空间布局
    新程序对子进程的继承：
    × 对close-on-exec =0(默认0) fd文件描述的继承
    × 继承子进程的信号处理：
      ×× 但对信号捕捉处理置为默认处理
      ×× 继承信号屏蔽集
      ×× 继承未决信号
    × 进程组id/会话组id/控制终端
    × 工作目录
    × 文件掩码
    × 资源限制
    × 文件锁
    × 闹钟的剩余时间
#守护进程:
    daemon process，即脱离了原shell会话，进程自己成为新会话的首进程。
    守护进程在后台持续运行，标准输入、输出、错误fd已close().
    > 创建守护进程:
        × 成为孤儿进程:
        × 建立新会话:
        ×改变继承自父进程的属性：
# 僵尸进程：
   top "查看僵尸进程的数量
   ps -ef 

-----信号-----
#信号：
> unix信号：
  内核在特定条件下产生信号并传递给进程(保存在该进程的PCB)，
  而进程一旦接收到信号，进程的主控制流程中断(软件中断)转而执行处理该信号。
  × 信号是软中断:
    进程由于
      中断(如键盘输入/网卡数据到来等硬件产生的硬中断)
      异常(访问非法地址/除以0指令等硬件产生的异常)
      系统调用(alarm/killd等系统调用)
      使得当前进程停止(停止是指暂停执行)并进入内核空间处理这些中断，异常，系
      统调用，处理好之后去检查进程pcb中已递达的信号并执行相应的信号处理操作
      ，而如果信号处理方式捕捉信号处理，则此时进入用户空间去执行捕捉信号处理
      函数控制流，而

      信号处理是软中断只是使得进程的主控制流程(当前线程)停止(暂停执行)转而
      去执行信号处理。即软中断中断的只是当前进程
      而不是中断cpu转而处理硬件驱动的中断请求子程序(这个是硬中断)

  × 信号是异步事件
       我们使用signal或sigacttion系统调用去注册信号处理函数(只是告诉内核
    等会如果我这个进程有某各信号递达就按照我注册的信号处理函数去处理)，
    进程本身不需要等待:信号递达->信号处理,所以叫做事件异步处理().
    当信号递达当前控制流会软中断(当前控制流程会暂停，而其他控制流并不受影响)
    去做这个信号处理，如果是捕捉信号处理，则处理完后会会返回中断点继续向下
    执行下一条指令。
        捕捉信号处理函数控制流和进程控制流是独立，两种拥有独立的堆栈(stack),
    但是两者就和同一进程的多个线程一样，都共享全局资源(堆，数据区,fd等),
    这可能引发资源竞争。
       linux提供的异步io也是异步(非阻塞)事件。而io复用本质上也是异步事件。

  × 信号捕捉处理方式的两个问题和解决
    a.信号捕捉处理函数执行中，是否应该再接收(同种或其他？)信号？
      如果这些信号捕捉处理函数是不可重入函数，为了避免形成竞争条件(线程不安
      全)，因此应该保证信号捕捉处理函数执行时不再接收(同种或其他)信号。
    b.怎么保证？
      1.sigaction()信号处理函数sa_flags默认支持在信号捕捉处理时defer延迟
        接收同种信号。
      2.通过setfill或sigprocmask函数去设置信号的屏蔽(即block阻塞、挂起)与否
    b.信号屏蔽可能会导致多次接收同一信号，只计一次(sigpending函数只返回
      是否挂起(屏蔽)，不反映次数)？
      1.信号捕捉处理函数应极快处理信号
        信号捕捉处理只负责将捕捉的信号写入fifo或基于socketpair()双向管道的写
        fd。信号捕捉处理函数的处理环节应放到其他控制流程。
        即信号捕捉处理凭借fifo/双向管道可以作为统一事件源，通过epoll去监听
        fifo/双向管道的读fd的EPOLLIN(可读事件)。见linux高性能-10.4统一事件源

  × 不可重入函数:
    上面讲到捕捉信号处理函数控制流程和进程的其他控制流程可能会引发资源竞争
    ,换句话说不可重入函数就是线程不安全函数。线程不安全函数如下：
    eg:
    a.系统调用malloc或free，因为malloc也是用全局链表来管理堆的。
      当前版本malocc/free实现有线程安全和不安全两个版本。
    b.标准I/O库函数。标准I/O库的很多实现都以不可重入的方式使用全
      局数据结构。    

  × 中断系统调用：
    见linux高性能服务器编程-10.1.4
    eg：
     文件读写write\read阻塞过长----linux会重启这些系统调用？
     sigsuspend因信号递达而被中断---没事，就是这样用的
  
> 信号阶段描述：
  × 产生的情形：
    特定条件下，内核产生信号。
     在本章节后面将举例SIGINT和SIGHUP产生处理流程
    a.键盘输入导致硬件中断:
      eg:
      ctrl+C,终端中断符->产生SIGINT->递达给前台进程组,默认动作是终止
      ctrl+\,终端退出符->产生SIGQUIT->同上，但默认动作是终止+coredump
      ctrl+Z,终端停止符->产生SIGSTP->同上,但默认动作是停止(暂停前台进程组）
    b.硬件异常：
      硬件检测到异常，通知给内核，内核产生信号给相应进程
      eg:
      除以0运算,运算单元算术异常->产生SIGFPE->当前进程->默认动作是终止+core
      无效内存引用,内存管理单元异常->SIGSEGV->当前进程->默认动作是终止+core
      伪终端(pts/2)与gnome-te连接断开->SIGHUP->整个会话->默认动作是终止/重载

    c.通过系统函数发信号给进程：
     eg:
      kill -MYTEST pid->自定义信号SIGMYTEST
      kill pid,终止->SIGTERM->默认动作(清理后)终止(实际该信号由应用程序捕获)
      kill -2 pid->SIGINT->见上
      kill -9 pid,终止->SIGKILL->默认动作是(不清理)强制终止。
    d.特定的软件条件：
      调用alarm系统调用,定时器超时->SIGALRM->默认动作是终止
      调用write系统调用,写至无读管道(或套接字)->SIGPIPE->默认动作是终止
      调用read系统调用，读到紧急情况(套接字)->SIGURG->默认动作是忽略
      

  × 阻塞：又称屏蔽
    信号产生后可以阻塞(block),而不递达给相应进程，直到修改为不阻塞该信号。
    可以通过系统调用函数sigprocmask传递需要修改和获取的
    阻塞信号集(sigset_t类型,bit位，signum=index+1，0/1表示不阻塞/阻塞信号)
  × 未决：又称挂起
    suspending。未决的意思是已产生但未递达。
    可以通过系统调用sigpending()获取
    未决信号集(数据类型同上，bit位0/1表示未产生/已产生但未决)
    往往当信号设置为阻塞时，产生某信号，使得对应的未决bit位置1。
    而未阻塞信号，当产生该信号时，几乎捕捉不到该信号未决位置1.
    如下：
    阻塞 未决
     0    0 "某信号不阻塞，也未产生过
     1    0 "阻塞，但未产生
     1    1 "阻塞，产生了当未递达

  × 递达：
    内核产生的信号已经按规则递给了相应进程，保存在进程的PCB上    [内核空间]
    进程立马？？执行信号处理(信号处理控制流)
  × 处理：递达就会立即进行信号处理
    ×× 进程对信号的处理方式：
       a.忽略信号：
         内核可以忽略信号处理                                    [内核空间]
          
       b.默认处理动作：
         内核采用信号默认的处理方式对相应进程进行处理            [内核空间]
         信号默认处理一般是终止进程(当然也可能是终止+coredump，忽略)
         !SIGKILL,SIGSTOP不可忽略，不可捕捉
       c.捕获信号处理:
         可以在用户空间使用系统调用signal捕获并注册信号的处理函数。
         处理函数为SIG_ING/SIG_DEF常量，表示忽略/默认处理。      [内核空间]
         自定义处理函数指定为函数地址，这叫捕捉信号处理，此时会进入用户空间
         执行该处理函数。[用户空间]
         ×× 信号处理函数执行顺序：
  × 返回主控制流程中被中断的地方继续执行下一行指令：
    这个步骤仅针对对信号捕获处理,只有这种信号处理方式采用返回继续执行。
    此时，当进入用户空间执行自定义信号处理函数返回后会，会调用sys_sigreturn
    系统调用进入内核，该调用返回后进入用户空间的主控制流程中断处继续向下
    执行。                                   [用户空间->内核空间->用户空间]

> 信号产生处理实例：
  × SIGINT:
    s1.用户输入命令last|sort，在Shell下启动一个前台进程。
    s2.用户按下Ctrl-C，这个键盘输入产生一个硬件中断。
    s3.如果CPU当前正在执行这个进程的代码，则该进程的用户空间代码暂停执行，
       CPU从用户态切换到内核态处理硬件中断。
    s4.终端驱动程序(这也内核的一部分)将Ctrl-C解释成一个SIGINT信号，记在该进
       程的PCB中也可以说发送了一个SIGINT信号给该进程）。
    s5.当某个时刻要从内核返回到该进程的用户空间代码继续执行之前，首先处理PCB
       中记录的信号，发现有一个SIGINT信号待处理，而这个信号的默认处理动作是
       终止进程，所以直接终止进程而不再返回它的用户空间代码执行。 
       而该信号实际会发给整个前台进程组，所有前台进程组中的所有进程都会终止
× SIGHUP:

    考虑：什么实体在何种情况产生什么信号对哪些进程产生什么影响        
        × SIGTSTP:交互停止信号
            a.在终端设备中(远程终端、本地终端、虚拟终端等)输入挂起键 ctrl+z
            b.由内核的终端驱动程序产生该信号
            c.发送至所在会话的前台进程组的每一个进程接收
            d.默认是停止(又称暂停、挂起)
              接收进程不可忽略、不可捕获该信号
        × SIGCON：此作业控制信号发送给需要继续运行的但当前处于停止状态的进程
            a.在终端或者脚本中执行fg,bg等
            b.由发送命令所接收的bash进程产生该信号
            c.发送至指定某个后台进程
            d.若接收此信号的进程暂停(T)，默认是使其恢复运行(R->S)
              否则默认是忽略。
        × SIGHUP：终端连接断开信号
            a.远程终端断开或本地终端终止会产生该信号并传递给会话首进程和&提交的进程
            b.若会话首进程终止(显然，通过断开远程终端或是终止本地终端或是直接终止会话进程) 
              ，则进而将该信号传递给前台进程组。
            c.显然，直接断开或是终止终端与直接终止会话首进程，导致的结果是不同的.
              此外，需要注意终端键入ctrl+c/ctrl+\/ctrl+z分别会使得终端的前台进程组
              中断/终止/挂起(SIGINT/SIGQUIT/SIGSTP)，因为这些信号会传递给前台进程组。
              而SIGHUP的传递是分a，b两种情形的。
            d.若接收到该信号，则默认是终止进程
              但若接收进程是守护进程，则守护进程会重新加载配置文件而不是终止进程。
            e.若是nohup+命令 &的进程，则默认是忽略该信号。
              否则一般操作时，当我们断开终端或是终止终端会使得所有提交的任务终止。
        × SIGTERM:等价kill pid或kill 15 pid
            正常终止信号，会进行资源清理和文件关闭等工作
            a.如终端输入kill pid、终端exit退出
            b.终端bash产生该信号
            c.指定进程或者
            d.默认是正常终止该进程
              但是该信号可以被捕获和忽略
              (如任意bash进程下有运行(R|S)的子进程，kill 该bash
               该bash会忽略该信号而不会终止该bash）
         × SIGKILL：
            强制终止信号，不资源清理和文件关闭等
            a.终端输入kill -9 pid命令、系统关闭时终止kill -15不能
              终止的进程、
            b.用户bash进程或内核产生？
            c.发送给指定进程
            d.默认是立即强制终止进程
              不可忽略、不可捕获
            (如kill bash进程 无效，而kill -9 bash进程有效
             若该bash是会话首进程，则该首进程产生sighup信号并
             发送给除其直接&后台进程的会话所有进程，导致接收到
             该信号并执行系统默认动作的进程而终止。
             如该bash不是会话首进程，则会将该bash所有子进程attach
             到gnome-terminal的父进程。
    × SIGCHILD:
        子进程状态改变时(终止或停止)，会递达给父进程这个信号。默认忽略。

# sinal和sigaction系统调用:
  现在的signal也如同sigaction能在一次信号捕捉处理后仍安装该信号捕捉
  处理函数。sigaction相比signal，能提供多种功能的信号处理修改和检查。
  但是，两者都对排队的同一信号只计一次，这会导致信号的丢失(不可靠信号\非
  实时信号)--
  针对不可靠信号：
  一种处理方法:
   采用基于io复用+pipe可读事件的统一事件源模型,即信号捕捉处
   理函数只负责递达与否标志写入pipe[1],信号的实际处理部分作为事件监听的事件
   处理。
 另一种则是：等看了apue 信号排队处理机制再说

# alram和pause系统调用：
  > alarm:实现定时器的一种方式
    定时器超时，进程接收SIGALARM信号,默认终止
  > pause:
    使得当前进程挂起，直到内核执行一个信号处理程序(不包括忽略处理?),
    挂起结束，pause返回-1,errno=EINTR。
  > sigsuspend:实现临界区避免信号中断;实现进程同步tell+wait功能
    设置新的进程信号屏蔽字，以便之前屏蔽但现在设置为未屏蔽的信号递达，
    信号递达信号处理完后信号屏蔽字恢复为该系统调用调用之前的值。
    这几步是一个原子操作，所以相对于sigprocmask+pause，sigsuspend更能
    避免pause因信号丢失而无尽挂起。
    该调用总是返回:
    -1 ，errno=EINT (被中断的系统调用)
  


       
              
        

#进程同步：
    >正文段共享：父子进程可能执行同一段逻辑，易导致父子进程代码逻辑不独立
        以及父子进程执行同一段代码逻辑可能结果不一样(变量值不一样、
        函数调用结果也不一样，如pid 、getppid()等)
    >进程竞争：多个进程对共享数据(如文件(如同时标准io输出至stdout)，)
        进行某种处理时，最后结果取决于进程运行顺序。
        ! sleep()休眠函数并不能保证进程的进行顺序。
    >进程竞争原因：系统负载和内核调度使得进程执行的时间点不确定。
        如apue 图8-12,打印是基于每个输出调用一次write，由于进程调度的原因
        其两个进程的输出交叉混合
    >进程同步：
        × 父进程等待子进程终止后再操作共享数据：
            a.父进程调用wait类函数。阻塞或非阻塞查询终止的子进程
            b.父进程调用signal(SIGCHILD,&wait_dosomething).即注册一个捕获
              SIGCHILD的信号处理函数，内核去负责等待检测进程是否终止并进行后
              续处理，父进程不用阻塞地检测终止的子进程，
        但每个线程都有自己独享的stack，register，(private memory??).

        × 子进程等待父进程终止后再操作数据：
            a.子进程阻塞轮询父进程是否结束。while(getppid()!=1) sleep(1);
            子进程终止后，父进程再对共享数据进行操作。浪费cpu时间。
        × pipe实现同步：见apue fig15-7
        × 信号机制：
        × IPC：
#进程间通信：
> pipe:基于内核管道(内核内存空间)
  × 特点：
    ×× 只能用于有亲缘关系的进程之间通信--因为pipe打开的两个fd，fork后可继承
    ×× 半双工，这里的半双工指的是对于pipe只能->fd[1]->fd[0]->数据流向
       一旦父子进程确定流向-通过close()关闭fd[],
       是父fd[1]->子fd[0]还是父fd[0]<-子fd[0]-流向就确定了。
    ×× 需要全双工则需要建立两个pipe。
       一读多写，最好使用fifo而不是pipe
       双向管道则使用socketpair()建立unix本地域套接字
    ××无名。管道缓冲区PIPE_BUF大小限制。无格式字节流。
  
  × 应用：子进程
    ×× 进程通信：见apue 15.2管道。
       eg:
       " 实现父子进程的父fd[1]-->子标准输入fd=0流向
         父进程:file--sfgets+buf+write-->fd[1]->
         子进程：->fd[0]->dup2(fd[0],STDIN_FILENO)复制+close(fd[0])->fd=0
         exec后:子进程新的程序pager继承fd=0那么新程序的标准输入将定向至fd[0]
         等价于只写popen("pager","w")。

       " 实现父子进程的父fd[0]<--子标准输出fd=1流向
         父进程读pipe<-子进程写pipe<-子进程dup2将写pipe复制到标准输出
         <-子进程的execl函数执行新程序标准输出
         等价于只读popen("")
       "模拟管道命令|
         父进程写fd[1]复制到标准输出--->子进程读fd[0]复制到标准输入
       "实现协程：
       上述第一和二组合以下--需要两对pipe--实现协同进程
         fd1[1]——————————————>STDIN_FILENUM
       父进程         子进程的新程序(作为数据过滤器)
         fd2[0]<————————————— STDOUT_FILENUM
    ×× 进程同步：见qpue fig15-7
      eg:
      "
      等待端是只读pipe，基于阻塞read()(等待内核管道缓冲区有数据)而wait对端。
      "
      非等待端是只写pipe，先行执行后基于write()(向内核管道缓冲区写数据)而
      tell对端。
        × 基本使用步骤：
            a.pipe(fd[2])生成pipe
            b.父进程作为只写，则close(fd[0])。反之
              --当无该pipe的只读fd打开而write时，write失败返回-1,errno=EPIPE
            c.子进程作为只读，则close(fd[1])。反之
              --当该pipe一个只写fd关闭时而read时，read会返回0.
    > fifo:基于文件系统。
        × 特点:相比于pipe
            × 可用于无亲缘关系的进程间通信。--进程知道已存在fifo文件的路径名就能使用该fifo文件
            × 一(读)对多(写)且半双工，需要全双工则需要建立额外的fifo。
            × 有名fifo文。仍有PIPE_BUF大小限制。仍是无格式字节流。
        ×应用：
            ×标准输出流非线性连接：
                pipe是线性连接：prog1<infile |prog2|prog3 
                fifo是非线性连接：
                    mkfifo fifo1
                    prog3<fifo1 & prog1<infile |tee fifo1|prog2 "tee将prog1的输出流复制给fifo1和
                                                                prog2
            × 实现1(读)对多(写)的服务器-客户进程通信。`

        × 基本使用操作:见后台开发核心技术与实践的fifo
            a.确定fifo路径名
            b.先运行端(如服务器)，access()判断fifo路径名是否已存在，已存在则execl()执行rm -f 
            c.mkfifo()建立fifo文件并设置文件权限(如0777)
            d.open()以O_NONBLOCK(非阻塞)且只读或只写打开fifo文件。对于fifo文件的open()必须设置为
              非阻塞(见apue p446)，使得该fifo的open操作和该fifo文件的后续io操作为非阻塞。
              对于非阻塞fifo，以只读open()则立即返回;在没其他进程只读open()打开该fifo文件时，
              以只写open()打开fifo，则立即返回-1,errno=ENXIN(设备或地址不存在)
            e:后运行端(如客户端)，则直接open该fifo即可。
            ---fifo保持了pipe的write，read的返回特性之外，还是非阻塞的(见上，文件io)

> 双向管道:socketpair()创建unix域本地套接字
#进程的存储空间布局：
#
#---------------------------------#
# 什么时候使用多线程：
  eg:
    服务器编程使用多线程去作多个io线程(epoll监测+任务队列)提供高并发性
    贪吃蛇使用多线程实现键盘监测和画面绘制分离---避免阻塞，提高实时性
    
#多线程内存空间与资源：
> 线程的独享：
  线程都有自己独享内存空间:
  × 栈
  × private memory??).
  线程资源独享
  线程各有一份独享的资源
  × 线程id
  × 上下文,包括各种寄存器的值、程序计数器和栈指针
  × 栈空间
  × 线程局部errno变量
  × 屏蔽信号集：
     新创建线程从调用进程了浮点环境和屏蔽信号集，但挂起信号置为空集。
  × 调度优先级

> 线程的共享：
  内存空间共享
  共享进程的内存空间:
  × 堆(动态内存)、
  × 数据段(全局和静态变量)、
  × 代码段(代码和常量字符串char* p="你好")--全局函数是否线程安全！
  线程的资源共享：
  × 文件描述符：
    1.只有线程能调用到文件描述符fd变量，如通过全局变量\作为线程函数型参
      就能实现多线程文件共享(同一fd、同一文件表项、同一读写缓冲
      但write和read操作fd时，由于系统调用的原子性，对文件fd
      的读写是安全但不同步(见上文件共享)
    2.线程对引用的fd进行close关闭，只是使得该fd引用计数减1,
      只有该引用计数为0时才会实际关闭文件(清理释放缓存+释放文件表项)
      线程终止时自动对引用的fd进行close
  × 文件指针:即标准io流
    线程也能共享其他线程打开的文件指针(标准io流)，如通过全局变量、
    线程函数传参等方式。从而从流的角度去实现文件共享。
    但通过标准io输入输出函数去操作文件指针时，不一定是安全的，也不同步。
     见上，文件共享
 
  × 线程访问共享资源的不一致性：
    虽然同进程下的线程之间通信很容易，但线程安全(互斥性/可见性/有序性)
    需要采用线程同步手段去保证。

#线程安全:
    >线程安全定义:
        ×调用者无需额外的同步操作调用，在多个线程中同时调用类/函数，
         无论操作系统如何调度这些线程(无论这些线程如何交织执行)
         都能表示出正确的行为(无运行时逻辑错误和异常错误)

    >线程不安全的原因:
        × 某些类/函数调用的非原子性(不一次性执行完)，在系统的线程调度下
         ，类/函数中所包含的共享内存资源在调用恢复前后(由于其他进程的修改)
         不一致(线程并不能感知这种内存修改),进而导致这些调用运行错误。
        × 中断：
        × 原子性:
          一个操作不可被系统调度(信号软中断/定时器/cpu进程调度/cpu线程调度)
          中断，要么全部执行完，要么一步都不执行。
            1.系统调用和汇编指令不都是原子操作
            2.典型++i/i++;if((!P)&&(p->IsEmpty))是非原子操作的
        ×内存不可见性:
            一个线程对共享内存内容的修改，另一个线程是察觉不到的，
            因此线程在调度恢复后，无法根据其使用的共享资源的修改，
            作出相应的代码修改。

    >线程安全原则:
        ×首先最低限度地共享对象:
            1的.将对象(类对象、变量)始终只在某个线程使用，不暴露给其他对象。
            2.如果要暴露，优先考虑immutable对象
            3.实在不行，要额外添加同步措施保护这些共享对象
        ×其次使用高级的并发编程构建:
            1.使用安全的线程安全库/类/函数，其自身内部提供同步措施
              调用者可在多线程中尽情使用。如:任务队列、生产者消费者队列、
              countdownlatch
            2.自定义的类/函数内部通过同步措施保证线程安全。
        ×最后不得以情况使用底层同步原语:
            1.只用非递归互斥器、条件变量、锁;慎用读写锁;不用信号量
            2.非跨平台开发，(like unix)可以考虑使用-pthread 线程库
              为了安全和易用，应自定义三类wrapper(包含最基本的11个线程函数):
              Thread:线程创建和结束
              MutexLock:互斥锁mutex的创建、释放、加锁、解锁
              Condition:条件变量的创建、等待、通知、广播
            3.跨平台则应使用c++11提供的线程库<thread>
        ×见muduo p31
    >c/c++系统库安全性:
# linux 线程api:
> pthread_exit():
  线程正常终止有两种，一是线程显或隐式调用return返回作为线程终止。
  另一种就是调用pthread_exit.这两种正常终止方式都能返回一个表示
  线程终止结果一级指针。
  ! pthread_join的&pthRetPtr二级指针去获取指定线程的终止结果指针。
  显然，我们能通过这个线程终止结果一级指针去传递共享变量(全局、静态、动态
  内存指针)给join它的线程。
  ! main中调用return或者exit，实际是进程终止而不是main线程终止。
    
> pthread_join:
  对于未分离的线程必须在(如主线程)其他线程调用(至多join一次某个线程)
  该函数去获取线程终止状态和回收线程资源。否则，会造成内存泄露。
  
# 线程通信：
# 线程同步之posix线程pthread:
    11个最基本、推荐使用的pthread函数，分三类:
    线程：
    >thread：
    >mutexlock:
    >condition：

    >酌情使用：
    >不推荐使用:
#线程同步之c++11线程库<thread>:
    c++11提供更为灵活的通用互斥量管理类，因此我们将采用的c++11多线程支持库
    划分为四个类别，每个类别包含一个或多个类(已经包装好的wrapper)：
    见www.cppreference.com查看c++线程支持的所有类别、类、类成员和类使用。
    >线程:
        × class thread:
            负责线程(对象)创建、销毁、管理(joinable/detach/join/get_id)等
            1.创建关联执行线程的线程对象的关联对象(型参)可以是一般函数、
              成员函数、仿函数等等。此时，创
              建线程对象就立马执行关联的执行线程。
            2.可以创建无关联执行线程的线程对象，但后续可以通过thread的移动
              赋值运算符函数进行赋值。
              eg:
                std::thread t;
                t= std::thread(fun1,arg1);//移动赋值后立马执行线程
            3.主线程调用join成员函数，即等待对应子线程运行终止并资源回收。
              主线程调用detach成员函数，对应子线程后台运行，内核负责其的
               终止后的资源回收。
        × std::this_thread命名空间：
            负责当前线程的重新调度安排、睡眠、当前threadid
    >互斥:
        × class mutex:基本互斥锁，即非递归且非时限互斥锁。
            1.该类提供了阻塞加锁、非阻塞加锁、解锁等成员函数
              但应尽量不使用
        × class 时限互斥锁、递归锁、递归时限锁等
    >通用互斥量管理：
        基于raii机制的互斥锁管理类(封装器)，保证资源获取就是初始化构造
        而资源释放就是析构，防止人为忘记资源释放。
        ×lock_guard:
            只提供基于作用域的对互斥量的加锁、解锁。
            1.lock_guard对象构造时自动加锁，析构时(如离开作用域)自动解锁。
            2.lock_guard不能复制和移动
        ×unique_lock:
            提供基于互斥锁类型的有限锁定、递归锁定、所有权转移等成员函数
            此外，支持与条件变量一同使用(lock_guard不支持条件变量)
            1.unique_lock只能移动，不能复制
        ×加锁策略:
            作为上述两个互斥量管理类的构造函数的第二个参数
            defer_lock:互斥量管理类构造时不加锁，延迟到手动调用其加锁成员
            try_to_lock:构造时非阻塞加锁
            adot_lock:构造时获取前面加锁的所有权
              
    >条件变量:
        解决通过使用循环占用互斥锁所有权判断条件成立时低效问题。
        
        × class condition_variable:
            1.使用互斥量保护条件变量
            2.while(条件) cv.wait():
                a.循环判断，防止虚假唤醒(wait线程并不一定能紧接在唤醒线程
                  之后重新占用互斥锁)
                b.wait()包括三个原子操作:解锁+等待、被唤醒、重新锁定;
            3.使用cv.notify_one（）防止惊群现象.
            4.应保证条件满足后再唤醒wait线程
            5.条件变量的唤醒操作在互斥量解锁之前或之后都可以。
    >future:
        × class promise:
            用于主线程thread构造函数参数传递给子线程使用
            1.::get_future()：获取future对象
            2.::set_value():设置子线程的promise对象的结果
        × class future：
            主线程中通过promise::get_future()获得传递给子线程promise
            对象对应的future对象。
            1.::get():阻塞获取子线程通过promise对象传递给主线程的结果
            2.::wait():阻塞等待
#线程死锁:
    线程阻塞地等待获取互斥锁锁的所有权，而该锁却因某种原因得不到释放，
    导致线程一直阻塞于锁定操作。
    >死锁的情况:
        基本都是因为线程叠加锁定两次导致的死锁
        1.线程对自身对同一个互斥锁叠加锁定两次。此时一定死锁
        2.两个线程对两个互斥锁叠加倒置锁定两次，在特定的时序发生死锁。
            线程1：A.lock()------------B.lock()--------
            线程2：--------B.lock()-----A.lock()----
            这时最常见、最隐晦的死锁。
            
    >防止死锁:
        对于死锁情况一我们的防止死锁思路是：
            杜绝显式或隐式地同一线程中对同一互斥锁叠加的锁定
        而对于死锁情况二我们防止死锁思路是：
            杜绝任意一对线程线程两个互斥锁相互倒置叠加锁定的情形。
            具体做法如1和2所示
        1.互斥锁的锁定区域不叠加：
            即层次锁
            线程1：A.lock()---A.unlock()---B.lock()--B.unlock()
            线程2：----A.lock()--A.unlock()--B.lock()--B.unlock()
            线程3:--B--~B--A----~A
        2.互斥锁锁定区域叠加但都是同序：
            线程1：A---B-----~A-----~B
            线程2：--A--B--~A--~B
        3.保证互斥锁锁定区域内调用的函数中不再有互斥锁锁定操作:
        4.muduo p40 ??

#线程通信:
    >线程之间共享内存：
        全局变量、静态变量、堆是全周期多线程共享的，
        栈则是生存周期内以引用或者指针可共享的
        × 面对过程程序设计角度：
            1.线程回调函数可直接通过变量名(值传递)共享全局变量  
            2.线程可将非全局共享资源以引用或指针作为回调函数的参数;
          
        × 面对对象程序设计角度：
            a.静态数据成员共享:
              基于类的静态成员只有一份拷贝，单例模式的类必须使用该方式。
                任何线程都可通过类::静态成员函数或对象::成员函数
                或线程回调函数内部调用该回调函数所在类的静态数据成员。
                eg:异步日志线程的回调函数为CAsyncLog类的静态成员函数，
                   日志线程便可经由该回调函数调用CAsyncLog类的静态数据
                   成员。
                   而主线程、其他线程都可通过CAsyncLog类
                   的静态output()函数共享CAsynLog类的静态日志队列数据成员。
            b.非静态数据成员:
                基于同一类对象内部所有成员函数(包括多个线程调用同一对象.成员
                函数)可共享该对象的数据成员。
                而不同对象之间的内存是独立的，是不可共享的。
                eg:
                    线程池类ThreadPoll对象创建线程池时均使用的是该对象的
                    线程回调成员函数。因此该线程池内所有线程均可通过
                    该线程池对象的线程回调函数访问该对象静态|非静态数据成员
    >线程之间传递信息：
        ×消息队列:
            自定义消息结构体(如time+type+src+des+content)
         +  队列(线程安全/不安全;queue/priority_queue)
         +  队列对象共享(全局/静态/堆/线程池类数据成员)
        × future

-----内核&&系统调用&&库函数&&&应用程序&&操作系统-----
    本书描述了UNIX系统的程序设计接口—系统调用接口和标准C库提供的很多函数。本书针对的是所有的程序员。
    与大多数操作系统一样，        系统调用接口和库函数可参见《UNIX程序员手册》第2, 3部分。本书不是这些内容的重复。
# 内核:
  管理硬件设备，供应用程序使用.
  对下，它管理系统的所有硬件设备；
  对上，它通过系统调用，向Library Routine（例如C库）或者
  其它应用程序提供接口。
  内核分为5个子系统，分别负责以下功能：
  > Process Scheduler:
    也称作进程管理、进程调度。负责管理CPU资源，以便让各个进程可以
    以尽量公平的方式访问CPU。

  > Memory Manager:
    内存管理。负责管理Memory（内存）资源，以便让各个进程可以安全地
    共享机器的内存资源。
    另外，内存管理会提供虚拟内存的机制，该机制可以让进程使用多于系统
    可用Memory的内存，不用的内存会通过文件系统保存在外部非易失存储器中，
    需要使用的时候，再取回到内存中。

  > VFS Virtual File System:
    虚拟文件系统。Linux内核将不同功能的外部设备，例如Disk设备（硬盘、
    磁盘、NAND Flash、Nor Flash等）、输入输出设备、显示设备等等，抽象为
    可以通过统一的文件操作接口（open、close、read、write等）来访问。这
    就是Linux系统“一切皆是文件”的体现（其实Linux做的并不彻底，
    因为CPU、内存、网络等还不是文件，如果真的需要一切皆是文件，
    还得看贝尔实验室正在开发的"Plan 9”的）。

  > Network:
    网络子系统。负责管理系统的网络设备，并实现多种多样的网络标准。

  > IPC inter-Process Communication:
    进程间通信。IPC不管理任何的硬件，它主要负责Linux系统中进程之间的通信。

# 系统调用:
  内核各个子系统提供了各种功能，而这些功能对应的服务就通过系统调用所调用
  UNIX为程序运行提供了大量的服务—打开文件、读文件、启动一个新程序、
  分配存储区以及获得当前时间等。这些服务被称为系统调用接口(system call
  interface)。
  > 系统调用接口规范：系统调用也叫系统函数
    系统函数调用出错时一般返回-1，如read/write
    
  > linux系统系统调用接口头文件路径:
    系统调用接口以头文件形式提供，而系统调用接口头文件路径为：
    /usr/include/x86_64-linux-gnu/bits/
  > 系统调用接口头文件：
    × <unistd.h>: 
      包含系统调用函数声明、系统调用常量、系统调用包裹函数声明
      a. 文件服务如read/write;
      b. STDIN_FILENO标准输入描述符号常量
      c.系统调用包裹函数：
        sleep() "
    × <dirent.h>:
      包含:
      a. dirent结构(目录表项结构体)
            
# 库函数：
  包括c标准库和其他库,而这些库函数可以是基于系统调用，也可以是自建。
  > 标准C库:libc/glibc
    提供了大量广泛用于C程序中的函数(格式化输出变量的值、比较两个字符串等)。
    <stdio.h>:
      常量:EOF;STDIN;STDOUT;STDERR;
      函数:getchar();printf()
  > 其他库

# 应用程序:
  应用程序可以基于库函数接口、直接调用系统调用接口

# 操作系统：
  从广义上说，操作系统包括了内核和一些其他软件，这些软件使得计算机能够发挥
  作用，并使计算机具有自己的特性。
  这里所说的其他软件包括系统实用程序(system utility),应用程序、shell
  以及公用函数库等。
  严格来讲，Linux是GNU操作系统使用的内核。一些人将这种操作系统
  称为GNU/Linux操作系

  
      首先解释什么是Core Dump。当一个进程要异常终止时，可以选择把进程的用户空间内存数据全部保存到磁盘上，文件名通常是core，这叫做Core Dump。进程异常终止通常是因为有Bug，比如非法内存访问导致段错误，事后可以用调试器检查core文件以查清错误原因，这叫做Post-mortem Debug。一个进程允许产生多大的core文件取决于进程的Resource Limit（这个信息保存在PCB中）。默认是不允许产生core文件的，因为core文件中可能包含用户密码等敏感信息，不安全。在开发调试阶段可以用ulimit命令改变这个限制，允许产生core文件。

------统一事件源/事件驱动
#事件：
  socket;信号捕捉处理+fifo/sokectpair双向管道;定时器;文件io
#事件统一监听：
  epoll 
# 多路io复用：
  epoll的ET模式应配合非阻塞io？
# 非阻塞io？
  >fcntl :设置文件为O_NONBLOCKING
  > 设置本次io操作为非阻塞

