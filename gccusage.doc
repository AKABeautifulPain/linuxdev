---------gcc 原理与使用-------------
#gcc/g++编译c/c++基本过程：
    > gcc:
        gcc是编译驱动程序，包含ccp、cc1、as、ld四个程序，依次处理预处理、
        编译、汇编、连接四个步骤。
        eg：gcc test.c -lapue -static -I/usr/include -o test 
        指定库名、库类型、(库路径)、头文件路径，-o test一步生成可执行文件
        .i,.s,.o三个中间文件临时存放值/temp/下。

    >ccp：预处理，替换宏定义、头文件，即.c ->.i
         eg:ccp test.c -o  test.i 等价于 gcc -E test.c -o test.i

    >cc1/cc1plus：编译，检查语法错误，将代码编译为汇编文件，即.i->.s
         eg:cc1 test.i -o test.s 等价于 gcc -S test.c -o test.s

    >as: 汇编，将汇编文件转化成二进制机器代码，即.s ->.o
         eg:as test.s -o test.o 等价于 gcc -c test.c -o test.o

    >ld：连接，将目标文件.o、静态库.a,链接成可执行文件并指定动态库名、路径
        待运行时连接。
        eg：ld test.o lapue.a -o test 等价于上述的gcc -o一步生成可执行文件

# 链接：自身源文件(自身编译单元)生成的目标文件会根据滋生包含的头文件的符号声
        明去链接gcc/g++编译译命令中指定的编译单元（源文件的目标文件或者指定的
        库文件）
    >重定义：同一编译单元或者编译命令中指定的其他编译单元，出现相同的符号
             (变量/函数/类定义才生成对应唯一的符号）
             导致调用处链接时不知如何选择。
        × 编译时重定义：同一编译单元内编译时，该单元内部出现相同的符号
             原因：
                a.同一编译单元包含重复同一头文件，而该头文件中可能由定义，
                   致重定义---解决：头文件条件编译
                b.同一编译单元多个头文件或源文件都定义某个符号导致重定义
                   ----头文件的定义和声明应分开;不要定义相同函数、变量、符
                   号
        × 链接时重定义：
            (源文件)编译模块A根据自己调用的头文件去链接其他包含该
            头文件的编译模块。导致两个编译单元的符号集之间命名冲突。
            注意：
                a.编译模块仅是包含这些头文件而未调用这些头文件中的内容
                  ，该编译模块也会去连接这些头文件对应的其他编译模块。从而
                  导致链接编译模块间的重定义。
                ！注意，即便上述调用了头文件的某个内容，该编译模块也会将所有
                  其包含的头文件对应的编译模块，进行链接。即便该个被调用的
                  内容未重定义，其他未被调用的内容可能也会报重定义。
                  具体和编译选项有关：
                  a.编译单元以单个列出：如g++ main.cpp a.cpp b.cpp
                    main.cpp中包含的头文件与a.cpp b.cpp关联，就会连接a.cpp
                    b.cpp.此时可能报重定义
                  b.静态库链接：如 g++ main.cpp -lab -L./ -o test
                    与a的同样条件下，g++只会链接libab.a静态库中的第一个.o，
                    此时，不会包重定义错误
                ！类即便定义在头文件，也不会引起链接重定义问题--因为类的声明
                   其实就是定义，类的定义其实是类的成员函数(也包括静态数据成
                   员)定义。此种情况，类的定义是局部的，该类定义不会参与链接
                   的符号比较。
                   类的重定义有两种情况：
                   a.类声明与定义分开时--链接类的定义可能链接到多个该类定义-
                   b.类的声明定义无论是否分开--编译单元存在或包含多个同名类-
                     --导致编译时的重定义。
        ×总之：
        1.头文件使用条件编译防止编译时重定义
        2.将声明与定义分开，声明写在头文件，定义写在源文件.(类的特殊性,见上)
#gcc/g++使用选项：未特殊声明，则c和c++都支持，往往以c++举例。
    >编译优化选项：
        × 编译优化往往以提高编译代价(时间、内存)和可调试性而提高生成代码的效
          率(bia执行速度、代码体积）
        × 编译优化是基于项目的多个文件全局优化，这时优化效果更好
        × 大多优化标志只能在某个优化级别"-O*"的优化集合中有效，其单独指定无效
          但基于某个优化级别的优化集合的些许有效改动可能有效。
        × gcc -Q --help=optimisizers 查看某个指定优化级别的确切有效优化集合
        -O：同O1级别
        -O0：
            不做任何优化，以减少编译消耗(时间和空间)并使得调试可以产生
            预期结果。往往用于debug版。(default)
        -O1：
            最基本优化，但不执行任何需要大量编译时间的优化，较少的增加编译
            消耗(尤其是大函数编译优化时)以减少生成代码的体积和代码执行时间。
            主要优化代码分支、表达式、常量。
        -O2：
            在-O1的基础上，进一步优化，几乎包含了gcc支持的所有支持的优化，
            但不涉及时间和空间的这种优化和循环展开、函数内联。
            相比O1,增加更多的编译消耗以进一步提高生成代码的性能(主要是运行
            速度)。
            主要优化增加了：寄存器级和指令级的优化。
            大部分公用库和开源服务器都使用的O2级别优化，是进一步提高代码效率
            同时尽可能保持代码可靠性的较好选择。
            虽然，在多线程和内存操作有可能遇到运行错误，甚至core dump。
        -O3：
            在O2的基础上，进一步优化，进一步提高代码执行速度，但增加了代码体
            积
            主要优化增加了：普通函数内联、针对循环预测展开等优化、加代替乘法
            、已有值代替未知值。
            O3级别优化试图预测程序走向，可能导致程序错误，一般不建议使用。
        -Os：
            在O2的基础上，进一步打开减少生成代码体积的优化选项，以进一步减少
            代码体积。
            相比O3宁愿增加代码体积以提供代码运行速度，Os则是在O2基础上减少
            生成代码的体积。适用于存储容量很小的嵌入式设备。
        -Og：
            启用不会干扰调试的优化选项，提供合理的优化水平同时保证快速编译
            和良好的调用体验。
        -Ofast：
            在O3的基础上，进一步打开非编译标准的优化选项，以进一步优化代码
            性能。
    >警告选项：
        × gcc通过一系列选项去显示或不显示程序的诊断结果。
          这些警告只是表示程序可能存在风险或者错误
        × 这些警告选项不是关于某个指定警告而是某一类警告
        × 多个警告选项之间可能是补充关系，也可能是局部抵消关系。

        -w：禁止所有警告信息
        -Wall：允许大多警告(具体的-Wall警告选项集合见gcc 手册)有效
            可单独指定禁止警告选项。(建议使用该选项)
            eg：
                "允许-Wall集合中除W-noused-varable警告选项外的警告
                gcc -Wall -Wno-unused-variable 
        -Wextra：允许相对-Wall额外的警告选项集合
    >语言标准控制选项：
        -std：
            指定语言标准。未指定该选项则默认c为-std=gnu11,c++为-std=gnu++14
            该选项可指定的值见，gcc手册
            eg：
                g++ -std=c++11      "c++11标准
                g++ -std=c++0x      "c++11草案(过渡标准)
                g++ -std=gnu++11    "含gnu扩展的c++11标准(非ISO-C++ feature
                                    "且极少冲突的扩展
                g++ -std=gnu++0x
        -ansi：特指-std=c90 或-std=c++98
    >预处理选项：
        -pthread：
            添加使用posix thread库时所需要的宏。<thread>实现用到<pthread.h>。
            应在编译和链接阶段都使用该选项，保持一致性。
            见编译选项中指定 -pthread 会附加一个宏定义 -D_REENTRANT，该宏会导
            致 libc 头文件选择那些thread-safe的实现；
            链接选项中指定 -pthread 则同 -lpthread 一样，只表示链接 
            POSIX thread 库。由于 libc 用于适应 thread-safe 的宏定义可能变化
            ，因此在编译和链接时都使用 -pthread 选项而不是传统的 -lpthread 能
            够保持向后兼容，并提高命令行的一致性。
    >调试选项：
        将调试信息插入汇编代码中(.s),经汇编器插入各个.o文件的符号表和
        串表中，最终经由连接器插入可执行文件的符号表和串表中        
        -g:
            `-g'选项启动只有GDB才使用的额外调试信息,调试信息格式默认是
             -dwarf-Version。gdb默认支持dwarf格式调试信息，但应确定gcc和gdb的dwarf版本是否匹配
             -g与优化选项同时使用时，尽量与-O0或-Og使用，以便生成预期的
             调试信息。
    -fno-elide-constructors ：关闭(类对象)返回值优化rvo
        在./c++返回值rvo/main.cpp中我测试了：
        func(){
            Test test;
            return test;
        }
        //1.测试1--rvo on|off
            Test mytest = fun();//在开启rvo(默认)时，只调用一次构造和一次析构
                                //在关闭rvo时，调用构造->构造->移构->析构->移构->析构->析构
        //2.测试2--rvo on|off
            Test mytest;
            mytest = fun();//在开启rvo，调用构造->构造->移赋->析构->析构 
                            //在关闭rvo，调用构造->构造->移构->析构->移赋->析构->析构
        rvo原理：在返回类对象以进行构造、赋值时，避免生成临时类对象变量产生的构造、移动/复制构造、析
                 构开销。值得注意的是，只要该类由移动构造或移动赋值成员函数，就会优先调用他们。
                 如果自定义复制构造函数、赋值或析构等成员函数,合成默认移动构造或赋值成员函数就会不见
    -fno-rtti: 关闭运行时类型确认rtti。gcc默认打开、vs默认关闭。
              
                      
#gcc/g++使用常见问题：
    > gcc -v :查看gcc配置信息configure，配置信息包括环境变量设置、
    include路径、库文件名、库路径）等

    > 查看头文件默认include路径：
        `g++ -print-prog-name=cc1plus` -v "输出g++所有include头文件查找路径
    >gcc -M test.cpp:查看生成的main.o的所有依赖(详细头文件路径，包括标准库头
         文件)，-MM 仅显示自定义的依赖.该选项仅生成.o有效,生成可执行文件无效
    
    > 库生成：自定义库的名字不要和标准库相同！！
        ×静态库生成：
            s1. 生成.o: 
                g++ -Wall  -c a.cpp b.cpp ==>a.o b.o
            s2. 打包.o生成.a: 
                ar rsc a.o b.o  -o libmyab.a ==>libmyab.a
            ar t libmyab.o :查看静态库的有哪些.o(升序排序)
        ×动态库生成：
            s1. 生成与位置无关的.o: 
                g++ -Wall -fPIC -c c.cpp d.cpp  ==>c.o d.o
            s2. 打包.o生成共享库: 
                g++ -shared c.o d.o -o libmycd.so ==>libmycd.so
            上述两步等价于: g++ -fPIC -shared -c c.cpp d.cpp -o libmycd.so

            ldd 可执行文件:查看可执行文件运行时实际调用了哪些共享库(包括标准
                库和自定义库;不显示库之间依赖关系)
    > 库链接:库搜索路径;库选择;库依赖;库内.o选择;
#

#库链接原理：
>静态库链接：

    将函数的代码从其所在地（目标文件或静态链接库中）拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。    静态链接的整个过程分为两步:
 

第一步：空间和地址分配。扫描所有的输入目标文件，获得他们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这样，连接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。

这里可能会有一个问题：建立了什么样的映射关系。如上面的图1，你可能就会有所了解。映射关系就是指可执行文件与进程虚拟地址空间之间的映射。那么，这里程序还没有执行，更不会出现进程，哪里来的进程地址空间呢？此时虚拟存储器便发挥了很大的作用：虽然此时没有进程，但是每个进程的虚拟地址空间的格式都是一致的。所以，为可执行文件的每个段甚至每个符号符号分配地址也就不会有什么错了。注意：在链接之前，目标文件中的所有段的虚拟地址都是0，因为虚拟空间还没有被分配，默认都为0.等到链接之后，可执行文件中的各个段已经都被分配到了相应的虚拟地址

第二步：符号解析与重定位

首先，符号解析。解析符号就是将每个符号引用与它输入的可重定位目标文件中的符号表中的一个确定的符号定义联系起来。

若找不到，则出现编译时错误。   

其次是重定位；

>动态库链接：
函数的定义在动态链接库或共享对象的目标文件中。在编译的链接阶段，动态链接库只提供符号表和其他少量信息用于保证所有符号引用都有定义，保证编译顺利通过。动态链接器(ld-linux.so)链接程序在运行过程中根据记录的共享对象的符号定义来动态加载共享库，然后完成重定位。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。

动态链接基本分为三步：先是启动动态链接器本身，然后装载所有需要的共享对象，最后重定位和初始化。
× 编译链接：
    × 加载链接：
    × 运行链接


#编译加载头文件:
> 编译加载自编头文件-源文件：
  前提:
   1.当某源文件调用其他自定义头文件,应该#include"**.h"格式而不是<**>
   2.该头文件对应的源文件中也应该#include"该自定义头文件.h".
  eg:
    "main.cppy引用Test类(Test.h,Test.cpp)
    g++ -g main.cpp Test.cpp -o exec "默认在当前目录搜索Test.h

# gcc/g++编译实例：
  " apue书中实例编译-调用libapue.a静态库和"apue.h"通用头文件 
  gcc test.c -lapue -static -I/usr/include -o test 

