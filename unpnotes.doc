---------网络编程----

-theme:network programming (linux)
-author：zitengfei
-date：2018.10.27
-describe:theory and programming about（linux）network
-----------------------------
#网络硬件：
      *网卡：即网络适配器，工作于数据链路层，是连接局域网中传输介质的硬件 。
          功能：串并转换;介质访问控制;数据缓存;编解码
          重点：系统可以dhcp方式动态获取ip等信息。
        或者手动设置网络适配器的ip、子网掩码、默认网关、dns服务器地址。
      ×交换机：工作于数据链路层，组成局域网的最关键硬件。
          功能：构成局域网，同一子网中的通信由交换机实现(根据mac地址进行数据交换)。
          重点：
             同一子网内的通信是dhcp服务+arp协议+交换机实现的。
             实际应用时，路由器就可以组建子网是因为，现代路由器
             集成交换机的功能。
     ×路由器：工作于网际层，是局域网访问外网的关键硬件
          功能：主机访问远程服务器时进行路由选择。
          重点：路由器是网关的扩展，因为网关是两端，而路由器是多端。
          当前，一般组网时，构成局域网使用交换机即可，当该局域网需要访问外网时
          则需将该交换机连接路由器。目前，一般的路由器都具有交换机功能。
          或则，将该交换机连接至拨号口，各主机都可独自拨号，独享自己的宽带。
     ×网关：不同网络之间的相互连接，完成协议转换等等。一般路由器都具有网关功能。
          重点:网关不是指具体硬件，路由器、防火墙、服务器、nat转换均是网关
#MSL，TTL：
    MSL:所有类型报文的最大生存时间。
    TTL：ip报文的生存跳数
#tcp/ip协议栈特点：
    ×tcp：面向连接、可靠的全双工字节流.多数据非实时传输
        ·连接：
            基连接。
           ! 一旦套接字对形成连接，那么不可以出现相同套接字对的连接
           ! 一旦套接字被某个应用程序定义使用，那其他程序不可以再使用该套接字，但是同一程序的不同进程仍可使用该套接字
           （如同一服务器程序的多个tcp子进程可使用同一个已连接tcp套接字）

        ·可靠：
            ·序列号：每个tcp分节（分段）都有一个序列号，便于排序和重复丢弃。
            ·确认：没收到一个分节就会回应一个确认号ACK  。
            ·超时重传：超过RTT时间未收到确认，就会重发分节，若该分节重发持续时间超过4-10分钟就是放弃重传并终止连接。
            ·流量控制：告知对端在任何时刻它能从对端接收的的字节数。确保接收缓冲区有足够空间接收来自对端的数据。
            ·拥塞控制：

        ·全双工：tcp对任意连接可提供两个方向上即能发送数据又能接收数据.当然也能转为单工连接。
                
            
    ×udp：无连接、不可靠全双工数据报。数据报长度随数据一同发送，即有记录边界，这一点不同于tcp字节流。少数据实时传输
        ·无连接:udp无连接--即客户和服务器之间不存在长期关系。
               一个客户udp套接字与一个服务器套接字通信后，可以立即用该套接字与另一个服务器套接字通信。
               服务器可使用同一套接字与若干个不同客户套接字通信

        ·不可靠：无序列号、确认、超时重传、流量控制、拥塞控制

        ·全双工：

        ·可在应用程序中添加代码实现：对端确认、本端超时与重传、拥塞控制
    ×stcp：不同于tcp，stcp特点如下。
        ·提供关联的连接：即多宿，连接的端点，可支持一组ip和一个端口，增强了网络通信的健壮性。
        ·头端阻塞最小：连接的端点之间支持多个流，单个流上的字节丢失不会阻塞，其后的数据递送（不同于tcp）
        ·面向消息：类似udp有记录边界，提供各个记录按序递送服务。

    !往往同一程序可tcp、udp、sctp协议同时，往往同一服务器程序使用一个端口，即该应用程序的不同类型通信进程使用同一端口。
    !而同一端点，不同程序不能同时使用同一端口，负责出现端口冲突错误
    !三者都是基于一对套接字（主动方-被对方;任意一方的套接字对应一对套接字地址结构），因此可以不同的套接字有相同的本地套接字地址结构


#######################TCP协议#####################

#tcp协议：
  > 序列号:
    标识tcp分组的数据部分(有效载荷)的第一个字节。
    × 对于syn报文、fin报文、数据传输报文均消耗一个序列号，
      对于单纯的ACK报文，该字段是无效的(即使有序列号)
      消耗序列号是指如果该分组被成功接收，那这个序列号就被消耗了。
      那么，显然消耗序列号的SYN、FIN、实际数据等报文
  > 标志位:
    SYN:
    ACK:
      返回含ACK位的分组：
      1.表示对接收信息的确认。
      2.表示滑动窗口字段有效。
      因此，分组出现ACK位至少表示发生上述两种情况的之一。
    FIN:
    PUSH:
    RST:

  > ACK机制：
    × 快速ACK:
      每接收一个分组返回一个ACK,而这个ACK可以是纯ACK报文，也可随数据报文
      一起(稍带ACK)响应给对端。
    × 延时ACK:即延时(累积)确认。默认开启。
      1.问题:
        90%的网络流量都是非交互式通信的批量传输(1500字节或更大)网络流量(web
        文件共享、邮件、备份)，对于这些全长分组多的数据若仍采用快速ACK,
        每收到分组都响应ACK分组，会加重网络负载，造成网络拥塞，进而导致
        网络拥塞(整体延时加大)。
      2.原理:
        延时ACK机制在延时ACK定时器(一般为200ms)未超时期间若接收到两个全长
        (MSS)分组就会返回一个ACK,否则超时后返回一个ACK。值得注意的是，若
        期间能稍带ACK,就立即稍带(即稍待延时ACK)。
        由此可见，延时ACK机制通过减少ACK包的数量，减轻网络负载、进而实现
        拥塞控制。
        linux系统采用了动态切换快速和延时ACK机制。
     3.特点:
        a. 延时ACK机制是一种从接收端角度对权衡网络拥塞和延时的一种折中方案。
           对于广域网/批量数据(如文件传输)，延时ACK机制能起到很好的拥塞
           控制作用。
        b. 延时ACK机制对于小分组、实时性要求高的交互式通信(如远程登录ssh、
           网络游戏)的拥塞控制并不是很有效，这种情况应采用下面提到的nagel
           算法。
           eg:ftp传输文件时，都指向单向传输的大量文件数据分组，并不需要
              对端及时响应，此时延时ACK机制。
        c.需要强调的事，延迟ACK机制并不会造成200ms的延时，往往实际会很小。
 > nagle算法:
    一种针对具有小分组、实时的交互通信，从发送端角度，减少发送小分组的
    数量，进而实现拥塞控制。默认是开启的。
      1.原理:
        nagel算法最基本的原则是对开启nagel算法的一端任意时刻连接中至多存在一
        个该端未被确认的小分组(<MSS).
        如果当前连接中存在一个该端的未被确认的小分组，则本端会尽可能收集小分
        组。在在此期间，已收集到一个MSS长度分组，则立即发送该MSS长度分组，
        否则，必须等到收到确认后，才可发送该新收集的小分组。
        如果当前连接中没有存在该端的任何未被确认的小分组，则该端
        会在200ms定时内，尽可能收集小分组，若定时等待期间已收集成一个MSS长度
        分组，则立即发送。否则，等到200ms后，才发送这个期间收集成的小分组。
      2.作用:
        a.正如ACK机制中所提到的，nagel算法能从发送端角度，有效对小分组的
          交互式通信，启动有效的拥塞控制。
          eg:
            ssh远程交互时，ssh客户端是默认开启nagel算法，以将客户端频繁的
            的小分组尽可能200ms内收集这些小分组。
            而这个200ms对于键盘交互并没什么大事
            见tcp/ip 卷一 p494.
        b.nagel算法具有自调节的"自时钟"特点，
          即网络越好，那开启nagel的一端发送的分组会越多。即RTT控制发送速率。
          如果网络拥塞严重，那即使nagel算法造成200ms，相对与对整个网络的拥塞
          加剧将导致的延时是不算长的。
        c.nagel算法和延时ACK机制一样，总体上并不会造成很大的延时。

 > 延时确认和nagel算法：
    高时延的广域网，一定要注意控制小分组的数目，避免加剧网络拥塞。
    而延时ACK机制和nagel算法便网络拥塞控制的方法之二。
    默认都是开启的。

    ×需要注意的是：
       这两个一起使用时，可能造成双方约200ms的死锁。详解tcp/ip卷一p497
     eg:
        ssh交互的命令执行结果响应期，客户端-开启延时ACK/服务器开启nagel算法
        可能双方发生200ms的死锁。
        
        
    



     



        
  > tcp建立连接三次握手:
        c-----------------------------------------s
          -------------SYN,syn=10------------->
          <------------SYN,ACK,syn=20,ack=11---//SYN报文虽为空数据，但实际消耗了一个序列号
          -------------ACK,ack=1-------------->//不返回ack=21,因为建立连接后实际使用相对序列号。
    > tcp建立连接后数据传输:
        c-----------------------------------------s
           ------push
    > tcp 11种套接字状态：netstat 查看网络连接信息，其中inet协议族中tcp套接字state字段。
                    包含：tcp连接建立三次握手和tcp连接释放四次握手中主动方和被动方
                    的各种状态。

        -> tcp连接建立三次握手：
                closed:客户端,服务端，表示未建立连接。

                listen：服务端，表示服务端的套接字处于监听状态，时刻监听来自客户端的连接申请

                SYN_SENT ：客户端，发送SYN报文后。
                         表示客户端已发送SYN报文(连接请求报文)。 这个状态与SYN_RCVD 状态相呼应，                           
                         当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随即进入到SYN_SENT 状态，
                         并等待服务端的发送三次握手中的第2个报文。

                SYN_RCVD ：服务端，接收到了来自客户端请求连接的SYN报文并发SYN+ACK报文作给客户端后。
                         在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，
                         基本上用netstat很难看到这种状态，除非故意写一个监测程序，将三次TCP握手过程中最后一个ACK报文不予发送。
                         当TCP连接处于此状态时，再收到客户端的ACK报文，它就会进入到ESTABLISHED 状态。

                ESTABLISHED ：客户端，接受SYN+ACK报文并发送ACK报文给服务端后;服务端接收到来自客户端的ACK报文后。
                         至此，TCP连接已经成功建立。
        ->tcp连接释放四次挥手：
            FIN_WAIT_1 ：客户端（主动方）-发送FIN报文给服务端（被动端）后。
                         表示主动方正在等待该端的连接断开。无论对方处于任何种情况下，
                         都应该马上回应ACK报文，所以FIN_WAIT_1 状态一般是比较难见到的，而FIN_WAIT_2 状态有时仍可以用netstat看到。

            FIN_WAIT_2 ：主动方，接收到来自服务端的ACK报文后。
                         表示主动方至被动方这个方向的数据流动已关闭，而被动方仍可发送数据给主动方
                         实际上FIN_WAIT_2状态下的SOCKET表示半关闭，调用shutdown(fd,SHUT_WR)可实现
                         (此时套接字的写关闭，进程不可对该套接字有任何写函数调用)，见unp p136
                × 服务器过多的FIN_WAIT_2状态套接字：
                    FIN_WAIT_2 是没有超时的（不像TIME_WAIT 状态），这种状态下如果被对方不配合
                    继续关闭(不配合完成4次挥手过程)那这个 FIN_WAIT_2 状态将一直保持到系统重启，
                    越来越多的FIN_WAIT_2 状态会导致内核crash。

            CLOSE_WAIT ：被对方，ESTABLISHED状态接受主动方FIN报文并发送ACK报文后。
                         表示正在等待关闭被动方的连接。主动方close()一个SOCKET后会发送FIN报文给被动方，
                         被对方会回应一个ACK报文给对方，此时主动方TCP连接关闭，被对方则进入到CLOSE_WAIT状态。
                         被对方在close_wait状态会检查自己是否还有数据要发送给对方，若无，被动方则close()这个SOCKET
                         并发送FIN给主动方，表示要关闭被对方到主动方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。
                         简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。
                    × 被对方（如服务器）当存在很多close_wait状态套接字时，此外会占用很多系统资源（套接字文件句柄数），
                            新的连接无法建立。此时，说明被对方很多程序处于半断开状态，需要检查被对方的程序问题（如close（）函数）
                            

            LAST_ACK ：被对方，CLOSE_WAIT状态下发送FIN报文后。
                         当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。
               
            TIME_WAIT ：主动断开方接收到对端FIN，发送ACK报文进入该状态。 
                主动方的TIME_WAIT状态持续2MSL(维持一个时间等待定时器2MSL)
                在时间内主动方会对接收到的被动方超时重发的FIN报文再次确认，
                并重新等待2MSL
                × tcp总是超时重传FIN报文，直至收到ACK报文，这就意味着。
                  FIN报文是可靠传输的而ACK报文并不是，见"序列号"。
                × 该状态下，这条tcp连接(四元组)，接收到的任何tcp数据报文
                  都被丢弃。
                × 该状态下，该五元组的新实例不允许被建立。
                  如该状态下的客户端立即重启后，将不能重新使用这一相同端口。
                (最大分段生存时间，指任意协议报文在网络中最长生存时间。
                 每个具体的TCP协议实现都必须选择一个确定的MSL值，
                 RFC 1122建议是2分钟，但BSD传统实现采用了30秒，Linux
                 可以cat /proc/sys/net/ipv4/tcp_fin_timeout看到本机的这个值）
                                            
                × 作用：
                    a.保证tcp全双工连接可以可靠关闭。
                      若主动方直接closed状态，则由于连接已断开，
                      即使被对方超时重发FIN报文给主动端，主动方已关闭而以RST报文响应，
                      该rst报文被被对方解释为连接异常而不是连接正常关闭。
                    b.保证该次连接的迷途数据有足够时间在网络中消失，避免造成新连接的数据混淆。
                 × 四次挥手变为三次挥手:
                    如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，
                    可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。
                 × 服务器过多TIME_WAIT套接字:
                    高并发短连接时，服务器将作为连接关闭主动方，此时可能出现过多
                    TIME_WAIT状态套接字情况，此时也会造成资源占用、新连接无法建立。
                    需检查服务器内核参数设置。

                CLOSING ：主动方、被动方-当双方几乎在同时close()一个SOCKET的话-双方几乎同时发送FIN报文给对方
                        该状态在实际情况中应该很少见，属于一种比较罕见的情况。
                        ！此时，主动方接收到被对方的ACK报文，进入TIME_WAIT状态。
                        
        -> tcp 各状态套接字个数统计：netstat -nat |awk '{print $6}'|sort|uniq -c|sort -rn
    >rst标志字段:
        连接取消、不正常时
        本端会强制关闭连接(而不是通过四次挥手正常关闭连接)，并发送
        RST报文告知对端连接已异常取消(不要再发数据给我)
        从而快速拆卸连接（RST接收端则会终止连接并通知应用程序
        当前连接已重置（）        
        ->特点：
            ×发送方会发送rst报文时会将发送缓冲区的数据丢弃以便立即发送RST报文
             (SO_LINGER选项可设置 等待一段时间内核发送缓冲区数据)
            ×接收方接收到rst报文后不必发送ACK报文确认。若接收方接收到rst报文后
             继续向发送方发送数据，write/send会报EPIPE错误，同时内核产生SIGPIPE
             信号，此时接收方进程默认行为是终止进程。
            × RST报文实际格式中RST和ACK都会置位，序列号(rst消耗序列号)和确认号也存在。 
              RST报文是不需要确认的。
        ->发送rst报文的几种情况：
            a.服务器端口不可用:
                连接建立时端口不对，服务器此时会发送RST报文给主机，告知连接不可用
                主动方connect返回-1且errno=ECONNREFUSED

            b.tcp连接请求超时:此时，若可以ping通说明网络没问题，网络层没问题。
                主动方发送SYN报文后，SO_RCVTIMEO时间内未收到被对方的
                SYN+ACK报文，此时主动方认为连接请求超时，发送RST报文给
                被d动方告知取消连接。
                主动方connect返回-1,errno=ETIMEOUT

            c.异常终止连接:
                当出现下列等情况时，会发送RST报文异常终止连接，见特点
                    1.close()时套接字接收缓冲区仍有数据
                        如客户端正常close(),而服务端read()返回-1且errno
                        置ECONNRESET。
                        这时因为客户端close()是接收缓冲区仍有数据但却被
                        丢弃了。此时客户端发送RST报文给服务端。服务端收到
                        RST报文仍继续读就会报错！
                        解决：客户端可采用shutdown()仅关闭本端套接字的write
                        那么此时并不影响本端的read，因此不会产生RST报文给
                        服务端，从而服务器read不会报错。
                    2.接收的数据有错
                    3.超时重传次数超过限制、网络暂时不可达
                此时tcp认为是异常连接终止。
              
            d.发送数据至已关闭套接字:整个区别于特点2.              
              即往半打开连接的已关闭套接字发送数据，已关闭端响应一个RST报文
              若打开端仍继续发送数据会收到内核产生的SIGPIPE信号，默认是终止进程，
              write/send返回-1且errno=EPIPE
              半打开连接:进程崩溃/主机崩溃，即便重启后，本端还是没有原连接信息，
              而对端连接还是保持打开，死等。而对端不进行任何read和write，这样
              是不知道对发已关闭(因为没收到reset报文)
            e.keeplive超时：
                此时本端保活定时器超时，会发送RST报文终止连接.
        ->问题：
            1.如果本端已接收到RST报文，read/write仍继续接收/发送数据，
              会分别返回ECONNRESET/EPIPE错误，产生信号？/SIGPIPE。
            2.如果对端异常终止(如进程崩溃、突然关机)，此时本端没收到RST报文的。
              假若此时本端不进行任何写是不会从对端收到RST报文的。
              本端进行读呢？
        
#-------------------套接字编程----------------

    > MSS、MTU:
        ->MTU：最大传输单元，数据链路层对网络层传下ip数据报大小限制。
             MTU主要是对UDP报文进行分片，因为MSS已经对TCP进行分段处理，避免了分片。

             MTU大小：
                a.两个主机通信链路之间的最小MTU成为路径MTU，相反两个方向的MTU可以不一样，因为路径不一样。
                  默认标准MTU为576字节，而主机一般支持mtu 1500字节
                b.ipv4最小链路MTU 68（20ip头+最多40的ip可选部分），ipv6最小链路MTU 1280（但ipv6可以运行MTU小于该值的链路上）
             MTU分片：
                a.ipv4,ip6发送的数据，若大于链路MTU，则会被ip协议分片，ipv4主机生成的数据执行分片，ipv4路由器转发的数据也会被分片。
                 ipv6只对主机产生的数据进行分片，ipv6路由器不对转发的数据分片。（ipv6路由器生成数据也会被分片，如路由器的telnet服务器）
                b.分片达到终点之前都不会被重组（作为路由器的防火墙，可能重组分片，以便查看整个ip报文）
                c. MTU主要是对UDP应用进程进行分片，因为MSS已经对TCP进行分段处理，避免了分片。       
                    
                eg:
                    若udp进程发送2000字节ip报文进入链路，由于MTU的限制（假设使用局域网MTU 1500），
                    该数据包被分为两片，1500ip报文，500+8 udp头+20 ip头=528 ip报文。（大于最小MTU）
                 ！！！发送udp数据报时应避免分片：
                        × 局域网下，使用MTU=1500==>udp发送数据<=1472,才不会分片
                        × internet下，使用MTU=576==>udp发送数据<=548,才不会分片(实际开发时建议这样限制udp数据报大小<=548字节)
                        × （总的来说，socket编程时，udp数据报长度小于64k，tcp则没限制)(这句话没什么意义？？)
            MTU不分片：
                a.默认分片，但通过将ipv4头部DF位置位，那么不管是发送数据的主机还是转发数据的路由器都不进行分片。
                b.当路由器接收到超过该外出链路MTU大小的且设置DF位的ipv4数据将返回一个ICMPv4出错消息，ipv6则返回一个ICMPV6出错消息。
                c.路径MTU发现：多次进行b操作，确定MTU大小。
        
                
        ->MSS：最大分段大小，传输层对应用层（仅针对使用tcp协议）数据大小的限制。
            MSS大小：
                a.一般是tcp连接建立时通过SYN分节（MSS可选选项），告诉对端本端希望接收的每个tcp分节数据部分的最大字节数(往往为1460字节)。
                b.若未通告则MSS，则mss默认为最小重组缓冲区大小-20ipv4头/40ipv6头-20tcp头。
                  其中ipv4最小重组缓冲区为576,ipv6为1500字节。
            MSS分段：TCP分节>MSS时，tcp协议会进行分段处理，
                eg:
                    一般(指定mss选项时)MSS=MTU-20 IPv4报头/40ipv头-20tcp 报头=1460/1440
                    如应用层数据1560 使用tcp/ipv4 协议传输，则被tcp协议进行分段处理，分为1460 和100 字节两段。


#套接字缓存区：
    每个套接字都由属于自己的(内核)发送缓冲区和接收缓冲区
    (实际上并不一定有如udp没有实际的套接字发送缓冲区)
    >套接字发送缓冲区：
        都可通过SO_SNDBUF套接字选项设置该缓冲区大小。
        × tcp套接字发送缓冲区：
            1.应用层进程调用write()发送数据：
                若套接字发送缓冲区容不下应用进程缓存区所有数据
              （可能是应用进程缓冲区大于套接字发送缓冲区或套接字缓冲区
                已有其他数据）
                此时应用进程投入睡眠（write调用阻塞），这里假设套接字
                是阻塞的，这是默认设置。内核不从write系统调用返回，
                直至应用进程缓冲区将数据全部复制到套接字发送缓冲区。
                write系统调用返回仅代表我们可以重新使用原来的应用进程
                缓冲区并不代表数据已经成功发送（即对端已经成功接收到数据）。
            2.流程：
                tcp应用进程调用write---tcp套接字发送将应用进程数据复制到套接字发送缓冲区后write调用返回-
                            -tcp协议mss处理-->ip协议MTU处理（一般不需要这步了）--->数据链路层的输出队列处理
                    （输出队列已满，则丢弃该分组，并向上返回给tco协议一个错误，tcp重传相应分节。应用层不知道这种情况。）---伴随本端收到对端的接收确认ACK，
                      至此本端才能从套接字发送缓冲区丢弃已确认的数据。
        × udp套接字发送缓冲区：
            1.udp应用进程调用sendto()发送数据：
                udp套接字没有实际的套接字发送缓冲区，只是可写到该udp套接字的
                udp数据报的上限。因此，也没有应用进程发送数据的副本。
            2.流程：
                s1:udp应用进程调用sento
                s2:大于udp套接字发送缓冲区大小限制（发送数据大于udp套接字发送缓冲区的大小），
                   则返回该进程一个EMSGSIZE错误。否则将应用进程数据复制至某种格式内核缓冲区。
                   (udp报文一定是整个报文形式复制到内核缓冲区)
                s3:ip协议根据MTU大小对udp报文进行分片处理-
                s4:数据链路层的输出队列处理（若输出队列没有足够空间存放该数据包或则他的片段，
                   则内核返回一个ENOBUFS错误给他的应用进程，
                   write调用成功返回表示所写数据报或其片段已被加入数据链路层的输出队列。


          × sctp套接字发送缓存区：
                  类似tcp套接字发送缓冲区，但是sctp无
                  传输层的MSS限制，同时sctp必须等待SACK，在累积确认确认点
                  超过已发送的数据后，才能从套接字发送缓冲区删除该数据。
    >套接字接收缓冲区:
        × tcp套接字接收缓冲区:
            1.应用层进程调用read()接收数据
                read()实质是从tcp套接字接收缓冲区复制数据至用户
                进程缓冲区。
                tcp套接字接收缓冲区的接收到的数据是真正传输过
                来的数据(内核已经帮我们相应ACK)。
                这一点从应用层(用户)---传输层（内核）的角度来看
                tcp报文的write和read是提供给应用层(用户)发送，接收
                的，实质的通信过程内核给我们完成。
            2.流量窗口:
                只有应用层调用read()从内核接收缓冲区读取数据，
                该内核接收缓存区才可腾出该部分空间，以接收新
                的数据。
                往往接收端读取数据比发送端发送数据的速度慢，
                这时就需要流量控制，以防止网络拥塞。
                




#套接字与套接字地址结构：
    > 套接字：
        使用套接字描述符标识套接字。
        a 主动方和被对方均由socket()生成的源socket套接字(被对方是源监听套接字)，
          socket()仅指定了协议族和套接字类型-见unp p95
        b.主动和被对方均通过自己的源套接字(被对方是源已连接套接字)进行数据的发送和接收。
        c.对于主动方，无需bind()绑定自己的源套接字地址结构
          对于被对方，需通过bind()绑定源套接字地址结构(注意绑定一个众所周知的服务端口)
    > 套接字对：
        定义一个连接的两个端点的四元组-源ip、源port、目的ip、目的port
        a.一个套接字对区分确定一个连接，并用于分离外来分节到多宿主机的不同端点。
    > 主动套接字：
        socket()函数创建的套接字，假设为主动套接字，即主动发起连接的套接字(客户端套接字)

    > 被动套接字：
        即被动接受指向该套接字的连接请求的套接字，因此，往往需要listen()将
        主动套接字转化成被动套接字，即监听套接字。(服务端监听套接字)

    > 监听套接字:
       （被动方/服务器端）listen()将主动套接字引用形参，转换为监听套接字，
        用于在服务器进程整个生命期内监听想要连接该服务器进程的客户端进程。
        a.某个服务器进程有仅只需一个监听套接字。
        b.监听套接字的ip和port,往往为*:众所周知的服务端口，表示服务器在本地任意网络接口
          等待连接请求。

    > 已连接套接字：
        (服务端)调用accept()将监听套接字作为引用行参，返回内核新生成一个已连接套接字
        (已完成tcp三次握手用于为每个连接服务端进程的客户提供服务，
        a.同一个服务器进程可以存在多个已连接套接字,这些已连接套接字的ip和port相同，
          并且是该进程的监听套接字(*：众所周知的端口号)的
           但他们的连接的套接字对却不同。

    > 套接字地址结构 ：
        是存放一组三元标识的结构体，可分为:
        源地址结构（源协议、源ip、源端口),
        目的地址结构（目的协议、目的ip、目的端口）
        
        × 套接字源地址结构：
            通信双方进程的套接字都有自己源地址结构，
            a.套接字可绑定自己的源地址结构与自己的源套接字，
              如服务端进程的套接字往往这样做。如服务端bind()将服务端的源(监听)套接字和
              源地址结构变量(*:众所周知的的端口)相绑定。
            b.套接字也可无需绑定自己的源套接字地址结构，而是由内核根据外出网络接口
              帮你确定源地址结构，这样就无需自行定义源地址结构变量。
              如客户端进程套接字这样做。如客户端只需connect()并只需指定客户端源套接字和
              目的套接字地址结构变量。
        >套接字目的地址结构：
            通信双方进程的套接字都有自己目的地址结构，一方的源地址结构就是另一方的目的地址
            结构
            a.客户端，往往需自行定义并初始化一个目的地址结构，以便tcp连接connect()时使用。
            b.服务端，不需要自行定义一个目的地址结构，因为服务端往往是被动连接方,其把接受的
              SYN报文的源地址结构作为自己的目的地址结构。

#网络分组字节序：
    包含分组的首部各字段和所含数据的字节序问题。
主机的cpu架构不同，因此为了使不同字节序的主机间正常通信，指定网络通信采用网络字节序。
而由于历史、posix规范，套接字地址结构的某些字段（端口和ip），仍需手动调用转换函数转换位网络字节序。

    ×主机字节序与网络字节序：

            >主机字节序:cpu结构不同，主机的字节序不同，intel x86 小端字节序列-低位字节存放在低地址

            >网络字节序：大端字节序--低-高。

    ×网络分组的首部字节序转换为网络字节序：（实际是对套接字地址结构中端口、ip进行转换）
            >端口：
                iton（），将16位整型端口号转为网络字节序的整型数。
            >ip: 
                itol（），将不含.的ascii字符串格式的ipv4地址转换为32位网络字节序的二进制（整型）数
            inet_pton(),将常用的点十分制的字符串格式的ipv4或ipv6地址转换位为32位网络字节序的二进制（整型）数
            其他函数,见unp

#阻塞、非阻塞和同步、异步：修饰的主体对象可以是进程、线程、函数（如套接字函数，io函数）

    > 阻塞、非阻塞：其区别的关键点是否进程会在调用结果（正确的结果或错误信息）返回之前，
        会因为等待（数据准备）过长（多长？）进入阻塞状态（即被动睡眠状态，即进程/线程释放cpu，但不释放内存）
        ! 广义阻塞：可以认为是进程等待调用执行直至返回调用结果，狭义阻塞：等待时间过长进程被动睡眠。
        ！非阻塞，不会因为长时间等待数据准备进入阻塞状态，因为，非阻塞调用时，如果在等待，此时会立即返回
        一个错误信息（关于描述操作等待态），因此，为了返回正确结果，应该循环调用该非阻塞调用i
        ，持续轮询查看该操作已经就绪。
        eg:
        "io操作可以是阻塞或非阻塞，一般由open或fcntl设置fd的阻塞是否。
        read/write;send/recive;sendto/recivefrom
        "
        wait是阻塞的
        waitpid一般是阻塞的，但可通过其型参设置为非阻塞。
    > 同步与异步：
        其区别关键点是返回调用结果的方式，是主动等待调用结果返回还是被动的由被调用者通知你返回结果。
       （如信号、事件、状态、回调函数）
        × 异步：
          异步调用一般会立即返回，而调用的处理结果会之后经由内核通知用户进程。见bd p255异步io
        × 异步io：
          在unp中,可认为异步io是非阻塞的异步io：即无需等待io调用完成，就立即将控制权返回给用户进程，
          而调用结果会之后经由内核通知调用用户进程。
          eg:信号是软中断也是异步事件，信号的发生(如子进程终止)是随机的，因此信号处理是先
             注册，"告诉内核，如果信号发生，就执行对应的信号处理"
        × 同步io:
          一般认为同步io都会阻塞:因为文件描述默认是阻塞的,从而对该fd的操作也是阻塞的(如read,write,见apuenotes文件io操作)
          对于网络通信,在套接字默认是阻塞的，其相关操作也是阻塞的:
            a 输入需等待数据到达(内核)套接字接收缓冲区--read()
            b 输出需等待套接字发送缓冲区有足够空间容纳将要发送的数据--write()
            c 客户端发起连接需等待对端回送对应的ACK报文--connect()
            d 服务器需等待连接已完成---listen()
          对于文件描述符，其默认是阻塞的，其相关操作也是阻塞的：
            a read阻塞于必须读取>0(但可<nbytes)
            b write阻塞于必须写入指定nbytes字节。见apuenotes 文件io

#网络io操作：
    >tcp 网络io：
        × read():
             a.阻塞模式:默认。
                阻塞是指接收缓冲区没有数据，read()会一直等待
                数据直到缓冲区有数据。
                而接收缓冲区一有数据阻塞read()就会读取并返回。
                因此需要手动while(>0)循环读至指定字节数。
                返回>0：读取到n字节，判断是否继续循环读取。
                返回值=0,读至文件尾--对端已关闭()
                返回值=-1,出错。errno存放错误类型。
             b.非阻塞模式下:
                若内核读缓冲区无数据，则立即返回-1,errno设为EAGAIN。

        × write():
            a.阻塞模式:
                 等待write()直到写入指定字节数--因此无需循环write。
                 返回值=-1.write错误。errno全局变量存放了具体错误类型。
                 返回值=指定字节数.写入成功---返回0,仅当写入字节数实参为0相关。
            b.非阻塞模式下:
                返回值(0,nbtye],即一次写入小于指定字节数--此时需要循环write
                返回-1，errno设为：
                    EAGAIN---套接字发送缓冲区已满--请继续尝试发送
                    EPIPE ---写至无读端
        × close():
            当close()函数关闭的是一个套接字fd，则该套接字fd
            不在可用，即不可再read和write该socketfd。
            将丢弃该tcp套接字接收缓存区的数据。
            将(内核)发送完tcp套接字发送缓冲区的之后，发送FIN报文给
            对端。
            进程的正常或是异常终止都会自动调用close()关闭fd
            
            返回值:
                该函数默认是立即返回，内核负责实质的发送缓冲区的剩余数据
                传输。可通过SO_LINGER套接字选项，改变这一行为。
                0：正确。
                -1：错误。
            
        × shutdown():
            相比较close(),该函数可以不管套接字描述符的引用计数是否为0就直接关闭
            该套接字描述符，此外还可以指定读写终止实现半关闭连接(close会读写全终止)。
    > udp 网络io：
        × sendto(): 为了保证成功发送，使用udp时应将发送数据大小小于等MTU-28(见udp分片)
            a.默认阻塞，但sento()的阻塞，并不像tcp发送阻塞时一样。
                sendto只是"非阻塞"的把数据放在数据链路队列
                返回值=0：仅但指定发送字节数=0时
                返回值(0,nbytes]：
                    只要发送指定字节数nbytes<=mtu-28(不分片)
                    应该就不会出现实际发送字节数小于指定字节数情况？？
                返回值=-1,errno置为：
                    EMSGSIZE    发送数据大于udp套接字伪发送缓冲区size限制   
                    ENOBUFS     数据链路队列无足够空间存放udp数据报或分片
                    EPIPE       写至无读端
            b.非阻塞模式下：sendto的非阻塞和阻塞一样

        × recvfrom：
            a.阻塞模式下：必须阻塞读取到一个udp数据报或分片
                返回值=0：并不像tcp读取一样表示对端关闭，而是仅表明对端sendto()0个字节
                返回值(0,nbytes]:成功接受一个udp数据报或分片。
                    1.显然，若udp发送端能限制发送字节保证发送数据不分片，那么udp接收时
                      要不就recvfrom错误，要不就recvfrom一次就接收一个完整的udp数据报
                      (前提是nbytes足够大，但nbytes足够大也不会一次接收超过一个udp数据报
                      ，即udp不会出现粘包(tcp会粘包))
                    2.若udp发送端发送数据分片，那此时recvfrom一次就接收一个分片，
                      那此时是否需要循环多次从而接收一个完整udp数据报？？
            b.非阻塞模式下：udp套接字接收缓冲区没数据，会立即返回-1，errno置EAGIN？





#网络io模型:
    > 阻塞:进程或线程等待(占用cpu时间)于系统调用返回调用结果，只有返回了系统调用结果才可向下继续执行。
        × 文件描述符默认是阻塞，导致针对该fd的系统调用是阻塞的：-----影响调用效率
            如socket套接字默认是阻塞的，则对其的系统调用：
                读(read/recv/recvfrom/),写(write/send/sendto),accept/connect是阻塞的。
            如普通文件默认是阻塞的，则对其系统调用:
                write,read是阻塞的
        × 大部分系统调用(一般是io接口，包括socket接口)是阻塞的：
          阻塞于两个阶段：数据准备(第一阶段)+内核和用户空间数据复制(第二阶段)
            以socket io为例：数据准备+数据复制
            read：等待内核接收缓冲区有一定数据-等待数据从内核接收缓冲区复制到用户进程缓冲区
            wrtie：等待内核发送缓冲区有一定空间-等待数据从用户进程缓冲区复制到内核发送缓冲区
                   
    > 网络io模型：
        × 阻塞io模型：<低并发(少量连接),使用多线程阻塞io模型>
            × 原理：
                进程/线程直接对(阻塞)套接字进程io操作，但是由于套接字默认阻塞的，导致套接字io是阻塞的，导致进程/进程阻塞
            × 特点：
                a 效率(时间，系统资源)低下：
                  因为进程/线程在socket io调用的的两个阶段都是阻塞的--socket io调用阻塞，导致整个进程/线程阻塞
                  ---系统资源长时间占用且无法继续执行任何运算且无法及时响应其他网络请求。
                b 简单，默认：是一种简单且默认的io操作使用
                c 小并发时，配合多线程使用，即多线程阻塞io模型。
        × 非阻塞io模型：<绝不推荐使用>
            × 原理：
                套接字设为非阻塞(因此套接字io非阻塞的)+循环主动检测数据准备好
            × 特点：
                a 循环检测，占用cpu资源，导致效率低下
        × io复用模型：<高并发(高连接数)时，配合异步响应使用=>现成的事件驱动库libevent，libev>
            × 原理：通过select/poll/epoll系统调用去同时主动检测多个fd(如socket)上是否数据准备好，即同时检测多个连接上
                是否有可读/可写/错误事件。又称事件驱动io/io多路转发模型。
            × 特点：
                a 能够同时检测多个连接：而阻塞io模型，一次只能检测一个连接。
                  当连接数很大时，io复用模型比阻塞io模型更有优势，更高效
                  当连接数很小时，由于select/poll/epoll本身就是系统调用，也是阻塞的。此时还不如用多线程阻塞io模型。
                b 配合异步响应，更高效：避免事件检测和事件响应夹杂在一起，降低事件检测的及时性
                  --->事件驱动库libevent，libev库(替代select/poll/epoll)提供异步响应并根据操作系统选择合适的事件探测接口
        × 异步io模型：
            × 原理：通过系统调用aoi_read/aoi_write将io接口调用的两个阶段交由内核处理，处理(读写完成)好内核会通知进程。
            × 特点：
                a 异步：其他三者均是同步io
                b 非阻塞：异步io调用进程在io接口调用两个阶段均是非阻塞的，其他三者并不是。
                                        
    >select/poll/epoll:
        × 相同点：
            a 均只是事件检测的手段：即均只是负责io操作的第一阶段，只是说三者能够同时检测多个连接(fd)
            b 均是同步阻塞的系统调用：
            c 返回值ret和检测时间timeout含义一样：
        × 不同点：epoll 仅linux支持，kqueue仅bsd支持，windows支持select和poll。
            ×select：
                a fd数量有限：监视的fd存储在静态数组，因此数量有限
                b 事件检测效率低：轮询存储fd的静态数组
                c fd数据结构传递开销大：需将存储fd的静态数组在用户进程和内核空间之间复制
            ×poll：
                a fd数量不限：采用链表存放受监控fd
                b 事件检测效率较低：仍采用轮询，但轮询的对象是受监控的fd链表
                c fd数据结构传递开销大：和select一样
            ×epoll：
                a 事件检测效率高，没有查询线性下降性能问题：采用回调机制+哈希列表，只有活跃的fd(连接)才会被检测到
                b fd数据结构存放在mmap内存映射上，无需在内核-用户内存之间传递：
                c epoll不仅支持水平触发还支持边缘触发：边缘触发更加高速率--但必须保证事件响应的彻底
            总之：在高并发(高连接)情况下，使用epoll;
                  低并发(少连接)情况下，使用select或poll会更好
#服务器多线程安全:
        × 类对象限制在其所创建线程中使用，则类的所有接口都不用加锁:
            eg:
            `class Poller ;class Channel;muduo p283

        ×类对象的部分接口可在非创建线程中使用，则这些out-otherthread 类接口和对应的out/in-inthread接口
          必须加锁和条件变量/基于eventfd(2)的wakeup()，实际是w-r+队列模式
          eg:
            EventLoop::runInLoop()          //实现(主线程)任务调度(新连接fd/定时任务timerfd/通知任务eventfd)
                                            //至working线程，见muduo p293
            
            EventLoopThread::startLoop（）  //实现一个线程(主线程)启动另一个线程并返回该启动线程创建
                                            //的EventLoop对象的指针,见muduo p298
    

#服务器高并发性能优化:     
        × 多线程/多进程：避免单线程由于某个连接的io调用阻塞(可能是第一阶段或第二阶段)而阻塞时不能及时处理其他连接。
        × 线程池：避免多线程时线程的频繁的创建，销毁，让空闲线程承担新连接。配合事件循环。
        × 异步响应：避免事件检测和事件相应夹杂一起，降低其他事件检测和事件响应的及时性。生产者--队列-
            ->io复用检测和事件响应分开:
                注册channel的回调函数--poll-->activeChannels--->while循环执行activeChannels列表的各个元素的回调函数。
        × 非阻塞：
            -> io复用应该使用非阻塞fd，保证读写真正的非阻塞
                若此时使用阻塞fd，在下列几种情况会出fd is  blocking 问题:
                a.虚假ready:
                    由于在io复用调用返回和read/write之间存在time window，导致虽然io复用检测blocking fd is ready for EPOLLIN/EPOLLOUT
                    但实际read/write操作时发现并非ready而block。
                    eg:
                        1.多进程io复用检测同一blocking fd
                        2.data has arrived at recvbuf but upon examination has wrong checksum and is discarded. 
                
                b.io复用only reports that  a fd is ready for w/r/e,rather than how much date can be w/r/e:
                    eg：
                        1.io复用检测写一个阻塞socket，阻塞写会阻塞的写完指定字节数或-1错误返回，此时阻塞会导致整个线程/进程阻塞
                c.edge triger epoll 必须使用非阻塞socket，以便可以读/写至返回值-1,errno=EAGAIN
    
                                     M
                                     |___W1__________ W2________W3
                      ----new read---|-->|----------->|-------->|
                                     |   |            |         |
                                     |epoll<--       epoll     epoll
                                     |   |   |        |         |
                                     |  C11 event     C21       C31
               --new connect--- ->accept |  loop      |         |
                                     | |C12  |       C22       C32
                                     | | |   |        |         |    
                                     | |C13  |    --> ~         ~
                                     | | |___|    |           
                                     | |          |        
                                     | |___add____|

            



#网络编程调试工具：
          netstat：查看套接字信息(proto;local&foreign address;套接字状态;对应pid/程序名);输出网络接口信息;输出路由表信息
                    (网络拓扑信息);
                eg:
                    1.netstat -anp | grep -w "端口号"  //查看具体某个端口号的套接字信息

                    2.：netstat -nat |awk '{print $6}'|sort|uniq -c|sort -rn
         ifconfig：查看、修改各个网络接口信息。如ip，mac，网关，子网掩码，mtu
